# SQL発展

* 文の終わりのセミコロンは、SQL文の終わりにつけるという理解でいい

* トランザクションとは  
⇒一つ以上のSQL文をカタマリとして扱うことが出来、このカタマリをトランザクションという。そして、SQL命令を受け取るDBMSがこのカタマリの間に割り込みが起きないようにする制御をトランザクション制御という  
⇒例えば、銀行にお金を振り込むという場合に、こちらの預金を減らしてあちらの預金を増やすというupdateを二回やる場合に、減らした後に停電でキャンセルされたら、こちらは減ったのに、あちらは増えてないということになる。これを二回のupdateを一つのカタマリとして扱うのがトランザクション（カタマリの一部だけを実行しないというシステム）。よって、どっちとも実行されないか、どっととも成功しているかのどちらかになる  
⇒このトランザクションで起こっている、このカタマリをこれ以上分割しないという性質を原子性という。これをどうやって実現しているかというと、一つのカタマリのSQL文（何文かある中）のうち一つが終わってDBが変更されると、仮確定になる。そして、全てが終わり、トランザクションを抜けると確定になる（この確定をコミットという）。なにか障害があれば、仮確定を外して、無かったことにするロールバックという操作がDBMSで行われる。  
⇒トランザクションを使うには、DBMSに開始と終了を伝える（３つ指示があり）  

★begin  
★commit  
★rollback  

```sql
begin;
-- 処理1: アーカイブテーブルへコピー
insert into 家計簿アーカイブ
select * from 家計簿 where 日付 <= '2018-01-31';

-- 処理2: 家計簿テーブルから削除
delete from 家計簿 where 日付 <= '2018-01-31';
commit;
```



🔺注意🔺；「自動コミットモード」  
⇒一部のDBMS付属のSQL実行ツールを使っていると、設定デフォルトにしているとなんと一行ごとに裏で自動コミットされてしまう時もある。一部のDBMSでは、beginを実行することで一時的にこのモードを解除することもできる  
（Mysqlでは、set autocommit = 0という文を実行するとモードが解除される）

* ダーティリード（未確定の数値をさらに他の値が引いてしまう結果、未確定が失敗に終わっているのに、他の数字が確定したものとして残額を出してしまう）  
⇒３万円預金があり、銀行で１万円を引き出す。先ず、預金から１万円を引いて２万円にする。この２万円の時に、光熱費を６千円落とされて、１万４千になった時に、銀行に障害が置きロールバックになった場合、、この先に引いてしまった１万４千という数字は光熱費がきちんと落とされれば確定してしまう

* 反復不能読み取り  
⇒select文の検索を何回かかけている時に、その間の途中で誰かがupdateしたら前後で結果に差異ができてしまうこと  

* ファントムリード  
⇒反復不能読み取りと似ていて、select文の検索を何回かかけている時に、その間の途中で誰かがinsertしたら前後で結果に差異ができてしまうこと

★これらの問題はトランザクションの分離性で解決する  
⇒「ロック」という機能。あるトランザクションが実行中に、そのデータがupdateやinsertをされても、その変更が影響しないようにすることで、結果を実行した時のものにする。つまり、自身が読み書きしたいDBがロックされているとその分変更を待たされる。このロックが多いとDBMSのパフォーマンスが落ちる原因になる。ただ、トランザクションはきちんとしたいという時に、どこまでのレベルでトランザクションするか指定することができる（トランザクション分離レベルの指定）
(ダーティリードだけを防いだり、反復不能までにしたり)
⇒postgresqlやoracleでは、コミットされてないと情報は読めないようになっており、常にトランザクション実行中に「書き換え前のデータ」と「未確定だが仮確定のデータ」二つあるようにしてあり、これを並列実行制御（ＭＶＣＣ）という

```sql
set transaction isolation level 分離レベル名
--DBMSによってどっちを使うかきまっている
set current isolation 分離レベル名

--分離レベル名
read uncommitted --postgresqlやoracleには存在しない一番危険
read committed --多くのDBMSはここがデフォルト設定
repeatable read --繰り返すことが出来るという意味
serializable --最も安全だが処理スピードは落ちる
```

* ロックについて

①行ロック  
⇒select文の末尾にfor updateを記述すると、他のトランザクションから書き換えが出来なくなる。また、さらに(nowait)を付けると、自身がロック中の行を書き換えようとした時に待機状態にならず、すぐエラーを返してくれる。

```sql
begin
select * from 家計簿
where 日付 >= '2018-02-01'
for update(nowait);
```

②表ロック

```sql
begin
lock table 家計簿 exclusive（ここがモード名） mode (nowait) ;
~~~~~~
commit;
```

* モード名  
⇒exclusive：排他的ロック  
⇒share:共有ロック

* デッドロック  
⇒データベースで沢山のトランザクションが実行されると、デッドロック状態になり、トランザクションの処理が永久に止まってしまうことがある。お互いにロックしようとしている行とお互いに既にロックしている行がクロスしてしまう。（Aさんはx行をロックして、次にy行ロックしたい、Bさんは、y行をロックしていて、x行をロックしたい。どちらもcommitしないとロックが解除されないので停止する。）  
⇒殆んどのDBMSには、片方のトランザクションを強制的に失敗させることによって解除する機能があり。また、この状態を避けるためにもトランザクションの時間を短くしたり、同じ順番でロックするようにするなどが対策としてある。

## 復旧について（間違えてdelete）

[SQLでテーブルデータを削除した時の復元方法](https://bebee5.com/sql-you-deleted-the-table-data/)

## createテーブル

★テーブルを準備、設定する立場（DDL:テーブルなどの作成や削除。各種設定など。DCL:DMLやDDLの利用に関する許可や禁止をする命令）  
⇒今まで学んできたのは、DML（データベースの格納や取り出し、更新削除など）、TCL（トランザクションの制御など）  
⇒commitやrollbackはTCLだが、DBMSによっては、DCLに分類されることもある

★DCLについて（データベースの管理者が仕事で行う）  
⇒誰にどのような操作やテーブル操作を許すかの権限を設定するためのSQL命令文の総称。

```sql
grant 権限名 to ユーザー名 --権限を付与
revoke 権限名 from ユーザー名 --権限をはく奪
```

### createテーブルのやり方

```sql
create table テーブル名 (
    列名１ date（列１の型名）,
    列名２ integer（列２の型名）,
    メモ varchar(100),
    入金額 integer,
    出金額 integer
)
```

★insert文で入力されなかったカラムのデフォルトの値を設定。  
⇒insert文で選択列とvaluesの数が合っていればデータを挿入できるが、選択されなかったカラムの値をnullではなく、入力されなかった際のデフォルトの値を設定可能(`create table (列名１, integer default デフォルト値, ~`))

```sql
CREATE TABLE 家計簿 (
  日付 DATE,
  費目ID INTEGER,
  メモ VARCHAR(100) DEFAULT '不明',
  入金額 INTEGER DEFAULT 0,
  出金額 INTEGER DEFAULT 0
)
```

🔶重要🔶：createテーブルの手順では、まずテーブルが存在しないことが重要(同じ名前のテーブルをつくることはできない)
⇒`delete from 家計簿`だとテーブルの中身しか消せないので、`drop teble テーブル名`をやらないといけない

🔶重要🔶：DML（4大命令とexplain, lock table）は、rollbackでキャンセル出来ることが多いが、DDL（create,drop, alter, truncate）は。ロールバック出来るかはDBMSによって違う

>PostgreSQL データベースでは、トランザクション内でデータ変更のロールバックだけでなく、DDL文(データ定義言語) もロールバックすることが出来ます。Oracle等のデータベースでは、ロールバックによってDDL文(データ定義言語)を取り消すことは出来ません。

★テーブル定義、設定の変更（alter table）  
⇒テーブルの「何を」「どう」変えるかを指定する必要あり。色々あるが代表的なのは、カラムの削除と追加。  
⇒カラムの追加は基本最後の列になるがDBMSでは任意の位置に指定できることもある。  
⇒テーブルの全行削除は、`truncate table`が使われる。

```sql
--カラムの追加
alter table テーブル名 add カラム名 型 制約
--カラムの削除
alter table テーブル名 drop カラム名 型 制約

--全行削除
truncate table テーブル名
--delete from テーブル名と違うのは、deleteではwhere句を使って一行消せるが、truncateは必ず全行。deleteはDML、truncateはDDL。deleteは記録を残すためにその分遅く仮削除という形を取るが、truncateは記録を残さないので高速でロールバックできない
```

★制約(constraint)
⇒人為的なSQL命令のミスを防ぐ対策として、「型」の設定（date型なのにintegerで打ってしまったり）や`制約`を使う
⇒「日付のカラムは絶対にnullにならないようにする」「入金額と出金額の数字は必ず０以上の値」など、一般的な制約では5種類ある。
⇒create tebleの「型」の後ろかdefaultの後ろに制約を記述（複数記述可能でコンマで区切らない）

```sql
CREATE TABLE 家計簿 (
  日付 DATE NOT NULL,
  費目ID INTEGER,
  メモ   VARCHAR(100) DEFAULT '不明' NOT NULL,
  入金額 INTEGER      DEFAULT 0 CHECK(入金額 >= 0),
  出金額 INTEGER      DEFAULT 0 CHECK(出金額 >= 0)
);
CREATE TABLE 費目 (
  ID      INTEGER,
  名前     VARCHAR(40)  UNIQUE
);
```

* not null  
⇒nullを許可しない
⇒defaultで何か文字を入れるときにこれもセットでつける（defaultで不明と入れるのでnullも許可しない）

* unique
⇒カラムの要素が被らない（nullはいくつ存在してもOK（null = nullではなく比較できない存在だから））

* check
⇒格納される値が妥当かチェックする

* primary key(そのカラムの要素をしていすれば、どの1行のことか完全に特定できる主キー)
⇒二つ記述方法がある
⇒🔶重要🔶：因みにその値の羅列が主キーの役割を果たしているのなら、外面では主キーとしては成り立つ。

```sql
--家計簿テーブルを子に持つ費目テーブルの費目idを主キーにする
CREATE TABLE 費目 (
  ID   INTEGER PRIMARY KEY,
  名前  VARCHAR(40) UNIQUE
)
--idカラムと名前カラムを二つ組み合わせて主キーにする
CREATE TABLE 費目 (
  ID   INTEGER NOT NULL,
  名前  VARCHAR(40) UNIQUE,
  PRIMARY KEY(ID, 名前)
)
```

★参照整合性
⇒ケースとして、家計簿テーブルと費目テーブルがあり、家計簿テーブルは外部キー（費目id）がある。家計簿テーブルの費目idは、費目テーブルのidを見れば必ずわかる。このリレーションシップが取れていることを参照整合性があるという。ここで、費目テーブルのidを一つ消してみると、家計簿テーブルの外部キーで不明な要素が生まれてしまう。これを参照整合性の崩壊という。この崩壊は、お互いリレーションで繋がっているのをどっちか勝手に値を変えてしまったり、消したり増やしたりすると崩壊するので、防ぐためには制約がある。

* references
⇒この場合、費目テーブルを作ってからではないと、家計簿テーブルの費目idカラムの制約でreferences出来ない？

```sql
CREATE TABLE 家計簿 (
  日付 DATE NOT NULL,
  費目ID INTEGER REFERENCES 費目(ID),
  メモ VARCHAR(100) DEFAULT '不明' NOT NULL,
  入金額 INTEGER DEFAULT 0 CHECK(入金額 >= 0),
  出金額 INTEGER DEFAULT 0 CHECK(出金額 >= 0)
)
--primary keyと同じで、行の最後にforeign keyとして付けることも可能
create table 家計簿 (
  ~~~~~

  foreign key (費目id) references 費目(id)
)
```

```sql
--練習問題
create table 学生 (
 学籍番号 char(8) primary key,
 名前 varchar(30) not null,
 生年月日 date not null,
 血液型 char(2) check (
                血液型 in('A', 'B', 'O', 'AB') or 血液型 is null),
 学部id char(1) references 学部(id)
)
```

🔶重要🔶：練習問題
⇒R(理学部)が廃止され、理学部の生徒はk(工学部)になる。この時に、学生テーブルと学部テーブルのリレーションを考えてsql文を考える。

```sql
begin;
update 学生 set 学部id = 'k'
 where 学部id = 'R';

delete from 学部
 where id = 'R';
commit;
```

⇒重要なのは、sqlの順番。先に学部テーブルのidを消してしまうと一時的に崩壊する。だから、先にRの学生をkに変えてから、学部テーブルのidのRを削除する。
⇒原子性を確保するために、トランザクションを使うこと。
