# SQL発展

* 文の終わりのセミコロンは、SQL文の終わりにつけるという理解でいい

* トランザクションとは  
⇒一つ以上のSQL文をカタマリとして扱うことが出来、このカタマリをトランザクションという。そして、SQL命令を受け取るDBMSがこのカタマリの間に割り込みが起きないようにする制御をトランザクション制御という  
⇒例えば、銀行にお金を振り込むという場合に、こちらの預金を減らしてあちらの預金を増やすというupdateを二回やる場合に、減らした後に停電でキャンセルされたら、こちらは減ったのに、あちらは増えてないということになる。これを二回のupdateを一つのカタマリとして扱うのがトランザクション（カタマリの一部だけを実行しないというシステム）。よって、どっちとも実行されないか、どっととも成功しているかのどちらかになる  
⇒このトランザクションで起こっている、このカタマリをこれ以上分割しないという性質を原子性という。これをどうやって実現しているかというと、一つのカタマリのSQL文（何文かある中）のうち一つが終わってDBが変更されると、仮確定になる。そして、全てが終わり、トランザクションを抜けると確定になる（この確定をコミットという）。なにか障害があれば、仮確定を外して、無かったことにするロールバックという操作がDBMSで行われる。  
⇒トランザクションを使うには、DBMSに開始と終了を伝える（３つ指示があり）  

★begin  
★commit  
★rollback  

```sql
begin;
-- 処理1: アーカイブテーブルへコピー
insert into 家計簿アーカイブ
select * from 家計簿 where 日付 <= '2018-01-31';

-- 処理2: 家計簿テーブルから削除
delete from 家計簿 where 日付 <= '2018-01-31';
commit;
```

🔺注意🔺；「自動コミットモード」  
⇒一部のDBMS付属のSQL実行ツールを使っていると、設定デフォルトにしているとなんと一行ごとに裏で自動コミットされてしまう時もある。一部のDBMSでは、beginを実行することで一時的にこのモードを解除することもできる  
（Mysqlでは、set autocommit = 0という文を実行するとモードが解除される）

* ダーティリード（未確定の数値をさらに他の値が引いてしまう結果、未確定が失敗に終わっているのに、他の数字が確定したものとして残額を出してしまう）  
⇒３万円預金があり、銀行で１万円を引き出す。先ず、預金から１万円を引いて２万円にする。この２万円の時に、光熱費を６千円落とされて、１万４千になった時に、銀行に障害が置きロールバックになった場合、、この先に引いてしまった１万４千という数字は光熱費がきちんと落とされれば確定してしまう

* 反復不能読み取り  
⇒select文の検索を何回かかけている時に、その間の途中で誰かがupdateしたら前後で結果に差異ができてしまうこと  

* ファントムリード  
⇒反復不能読み取りと似ていて、select文の検索を何回かかけている時に、その間の途中で誰かがinsertしたら前後で結果に差異ができてしまうこと

★これらの問題はトランザクションの分離性で解決する  
⇒「ロック」という機能。あるトランザクションが実行中に、そのデータがupdateやinsertをされても、その変更が影響しないようにすることで、結果を実行した時のものにする。つまり、自身が読み書きしたいDBがロックされているとその分変更を待たされる。このロックが多いとDBMSのパフォーマンスが落ちる原因になる。ただ、トランザクションはきちんとしたいという時に、どこまでのレベルでトランザクションするか指定することができる（トランザクション分離レベルの指定）
(ダーティリードだけを防いだり、反復不能までにしたり)
⇒postgresqlやoracleでは、コミットされてないと情報は読めないようになっており、常にトランザクション実行中に「書き換え前のデータ」と「未確定だが仮確定のデータ」二つあるようにしてあり、これを並列実行制御（ＭＶＣＣ）という

```sql
set transaction isolation level 分離レベル名
--DBMSによってどっちを使うかきまっている
set current isolation 分離レベル名

--分離レベル名
read uncommitted --postgresqlやoracleには存在しない一番危険
read committed --多くのDBMSはここがデフォルト設定
repeatable read --繰り返すことが出来るという意味
serializable --最も安全だが処理スピードは落ちる
```

* ロックについて

①行ロック  
⇒select文の末尾にfor updateを記述すると、他のトランザクションから書き換えが出来なくなる。また、さらに(nowait)を付けると、自身がロック中の行を書き換えようとした時に待機状態にならず、すぐエラーを返してくれる。

```sql
begin
select * from 家計簿
where 日付 >= '2018-02-01'
for update(nowait);
```

②表ロック

```sql
begin
lock table 家計簿 exclusive（ここがモード名） mode (nowait) ;
~~~~~~
commit;
```

* モード名  
⇒exclusive：排他的ロック  
⇒share:共有ロック

* デッドロック  
⇒データベースで沢山のトランザクションが実行されると、デッドロック状態になり、トランザクションの処理が永久に止まってしまうことがある。お互いにロックしようとしている行とお互いに既にロックしている行がクロスしてしまう。（Aさんはx行をロックして、次にy行ロックしたい、Bさんは、y行をロックしていて、x行をロックしたい。どちらもcommitしないとロックが解除されないので停止する。）  
⇒殆んどのDBMSには、片方のトランザクションを強制的に失敗させることによって解除する機能があり。また、この状態を避けるためにもトランザクションの時間を短くしたり、同じ順番でロックするようにするなどが対策としてある。

## 復旧について（間違えてdelete）

[SQLでテーブルデータを削除した時の復元方法](https://bebee5.com/sql-you-deleted-the-table-data/)

## createテーブル

★テーブルを準備、設定する立場（DDL:テーブルなどの作成や削除。各種設定など。DCL:DMLやDDLの利用に関する許可や禁止をする命令）  
⇒今まで学んできたのは、DML（データベースの格納や取り出し、更新削除など）、TCL（トランザクションの制御など）  
⇒commitやrollbackはTCLだが、DBMSによっては、DCLに分類されることもある

★DCLについて（データベースの管理者が仕事で行う）  
⇒誰にどのような操作やテーブル操作を許すかの権限を設定するためのSQL命令文の総称。

```sql
grant 権限名 to ユーザー名 --権限を付与
revoke 権限名 from ユーザー名 --権限をはく奪
```

### createテーブルのやり方

```sql
create table テーブル名 (
    列名１ date（列１の型名）,
    列名２ integer（列２の型名）,
    メモ varchar(100),
    入金額 integer,
    出金額 integer
)
```

★insert文で入力されなかったカラムのデフォルトの値を設定。  
⇒insert文で選択列とvaluesの数が合っていればデータを挿入できるが、選択されなかったカラムの値をnullではなく、入力されなかった際のデフォルトの値を設定可能(`create table (列名１, integer default デフォルト値, ~`))

```sql
CREATE TABLE 家計簿 (
  日付 DATE,
  費目ID INTEGER,
  メモ VARCHAR(100) DEFAULT '不明',
  入金額 INTEGER DEFAULT 0,
  出金額 INTEGER DEFAULT 0
)
```

🔶重要🔶：createテーブルの手順では、まずテーブルが存在しないことが重要(同じ名前のテーブルをつくることはできない)
⇒`delete from 家計簿`だとテーブルの中身しか消せないので、`drop teble テーブル名`をやらないといけない

🔶重要🔶：DML（4大命令とexplain, lock table）は、rollbackでキャンセル出来ることが多いが、DDL（create,drop, alter, truncate）は。ロールバック出来るかはDBMSによって違う

>PostgreSQL データベースでは、トランザクション内でデータ変更のロールバックだけでなく、DDL文(データ定義言語) もロールバックすることが出来ます。Oracle等のデータベースでは、ロールバックによってDDL文(データ定義言語)を取り消すことは出来ません。

★テーブル定義、設定の変更（alter table）  
⇒テーブルの「何を」「どう」変えるかを指定する必要あり。色々あるが代表的なのは、カラムの削除と追加。  
⇒カラムの追加は基本最後の列になるがDBMSでは任意の位置に指定できることもある。  
⇒テーブルの全行削除は、`truncate table`が使われる。

```sql
--カラムの追加
alter table テーブル名 add カラム名 型 制約
--カラムの削除
alter table テーブル名 drop カラム名 型 制約

--全行削除
truncate table テーブル名
--delete from テーブル名と違うのは、deleteではwhere句を使って一行消せるが、truncateは必ず全行。deleteはDML、truncateはDDL。deleteは記録を残すためにその分遅く仮削除という形を取るが、truncateは記録を残さないので高速でロールバックできない
```

★制約(constraint)
⇒人為的なSQL命令のミスを防ぐ対策として、「型」の設定（date型なのにintegerで打ってしまったり）や`制約`を使う
⇒「日付のカラムは絶対にnullにならないようにする」「入金額と出金額の数字は必ず０以上の値」など、一般的な制約では5種類ある。
⇒create tebleの「型」の後ろかdefaultの後ろに制約を記述（複数記述可能でコンマで区切らない）

```sql
CREATE TABLE 家計簿 (
  日付 DATE NOT NULL,
  費目ID INTEGER,
  メモ   VARCHAR(100) DEFAULT '不明' NOT NULL,
  入金額 INTEGER      DEFAULT 0 CHECK(入金額 >= 0),
  出金額 INTEGER      DEFAULT 0 CHECK(出金額 >= 0)
);
CREATE TABLE 費目 (
  ID      INTEGER,
  名前     VARCHAR(40)  UNIQUE
);
```

* not null  
⇒nullを許可しない
⇒defaultで何か文字を入れるときにこれもセットでつける（defaultで不明と入れるのでnullも許可しない）

* unique
⇒カラムの要素が被らない（nullはいくつ存在してもOK（null = nullではなく比較できない存在だから））

* check
⇒格納される値が妥当かチェックする

* primary key(そのカラムの要素をしていすれば、どの1行のことか完全に特定できる主キー)
⇒二つ記述方法がある
⇒🔶重要🔶：因みにその値の羅列が主キーの役割を果たしているのなら、外面では主キーとしては成り立つ。

```sql
--家計簿テーブルを子に持つ費目テーブルの費目idを主キーにする
CREATE TABLE 費目 (
  ID   INTEGER PRIMARY KEY,
  名前  VARCHAR(40) UNIQUE
)
--idカラムと名前カラムを二つ組み合わせて主キーにする
CREATE TABLE 費目 (
  ID   INTEGER NOT NULL,
  名前  VARCHAR(40) UNIQUE,
  PRIMARY KEY(ID, 名前)
)
```

★参照整合性
⇒ケースとして、家計簿テーブルと費目テーブルがあり、家計簿テーブルは外部キー（費目id）がある。家計簿テーブルの費目idは、費目テーブルのidを見れば必ずわかる。このリレーションシップが取れていることを参照整合性があるという。ここで、費目テーブルのidを一つ消してみると、家計簿テーブルの外部キーで不明な要素が生まれてしまう。これを参照整合性の崩壊という。この崩壊は、お互いリレーションで繋がっているのをどっちか勝手に値を変えてしまったり、消したり増やしたりすると崩壊するので、防ぐためには制約がある。

* references
⇒この場合、費目テーブルを作ってからではないと、家計簿テーブルの費目idカラムの制約でreferences出来ない？

```sql
CREATE TABLE 家計簿 (
  日付 DATE NOT NULL,
  費目ID INTEGER REFERENCES 費目(ID),
  メモ VARCHAR(100) DEFAULT '不明' NOT NULL,
  入金額 INTEGER DEFAULT 0 CHECK(入金額 >= 0),
  出金額 INTEGER DEFAULT 0 CHECK(出金額 >= 0)
)
--primary keyと同じで、行の最後にforeign keyとして付けることも可能
create table 家計簿 (
  ~~~~~

  foreign key (費目id) references 費目(id)
)
```

```sql
--練習問題
create table 学生 (
 学籍番号 char(8) primary key,
 名前 varchar(30) not null,
 生年月日 date not null,
 血液型 char(2) check (
                血液型 in('A', 'B', 'O', 'AB') or 血液型 is null),
 学部id char(1) references 学部(id)
)
```

🔶重要🔶：練習問題
⇒R(理学部)が廃止され、理学部の生徒はk(工学部)になる。この時に、学生テーブルと学部テーブルのリレーションを考えてsql文を考える。

```sql
begin;
update 学生 set 学部id = 'k'
 where 学部id = 'R';

delete from 学部
 where id = 'R';
commit;
```

⇒重要なのは、sqlの順番。先に学部テーブルのidを消してしまうと一時的に崩壊する。だから、先にRの学生をkに変えてから、学部テーブルのidのRを削除する。
⇒原子性を確保するために、トランザクションを使うこと。

### index（DDL）

★カラムにindexというものを付与出来る（インデックス名は何でもいい）  
⇒where句で検索に指定されたカラムに要素検索が早くなる  
⇒`create index インデックス名 on テーブル名(列名)`はカラムにindexを追加  
⇒`drop index インデックス名`はカラムからindexを削除  
⇒複数のカラムをまとめて一つのindexを付けることができる  
⇒indexには、並び替えを早くする効果もあるのでorder byの指定の時も早くなる。これは、joinの紐づけの時もそうであり、対応したカラムを結んだ後の並び替えも早くなる（外部キーにindexを付ける）
⇒`名前`もindexを付けると良い

```sql
create index 費目idインデックス on 家計簿(費目id)
create index メモインデックス on 家計簿(メモ)
--このインデックス名は、dropする時にも使う
```

```ruby
class CreateUsers < ActiveRecord::Migration[6.0]
  def change
    create_table :users do |t|
      t.string :name, null: false
      t.string :email, null: false
      t.string :password_digest, null: false

      t.timestamps
      t.index :email, unique: true #emailの検索の時に早くなる？
    end
  end
end
```

★データベースで作成することのできる索引情報はインデックスと呼ばれる。  
⇒インデックスのある列を検索する場合に、DBMSでは自動的にインデックスを使用するのでDBが高速になる（検索によってはインデックスを使用できないこともある）  
⇒インデックスは列ごとに作成され、例えば、費目idカラムに関するインデックスを作ると、検索条件に費目idを指定した検索は早くなる。  

* where句による絞り込み  
⇒where 費目 = '不明' のような完全一致の時に主にindexが使われ、検索が早くなる  
⇒like検索の1月の%みたいな前方一致検索の時にも早くなることある。（後方や位置に関係ない任意一致ははやくならない）

🔶重要🔶：indexを付けるカラムの選び方

★上記を読むと全てのカラムにindexを付け方がいいように思えるがそうではない  
⇒indexを付けるほど。ディスク容量を消費する  
⇒テーブルのデータが変更されるとインデックスも書き換える必要あり、insert文, update文, delete文のオーバーヘッドが増える
（インデックスが作成されている、カラムのデータを変更するということはそれぞれの要素に付いた振り分け数を変えるということであり、順番を変えないといけないので更新処理が重くなる）
⇒結果indexは乱用しないで必要なカラムのみにつける

### ビュー

★下記のように4月系の検索をしたい時に、同じsql文を書かなくていいようにビューという形でデータの内容をテーブルのように参照できる方法。下記で言えば、上の文を丸々ビューにして4月部分をビューとして参照できれば、またwhere句で条件を記述する必要が無い

```sql
select * from 家計簿 
where 日付 >= '2018-04-01'
and 日付 <= '2018-04-30';

select distinct 費目id from 費目 
where 日付 >= '2018-04-01'
and 日付 <= '2018-04-30';
```

```sql
-- create view ビュー名 as select文
-- drop view ビュー名    消すとき
create view 家計簿4月 as 
select * from 家計簿
where 日付 >= '2018-04-01'
and 日付 <= '2018-04-30'
～～～～～～
--上記の2文を以下にできる
select * from 家計簿4月; --4月しか出ないので絞る必要が無い
select distinct 費目id from 家計簿4月;
```

```sql
--家計簿テーブルの費目idと費目テーブルのidをjoinで紐づけて出来たテーブルをビューとして参照する。
CREATE VIEW 費目名付き家計簿 AS
SELECT * FROM 家計簿
  JOIN 費目
    ON 家計簿.費目ID = 費目.ID
```

★ビューでは、逆に表示したくないテーブルの一部をDCLのgrant文を使って設定もできる。  
⇒テーブル内容AとBがあって、Aだけをビューで参照して、そのビューをアクセス禁止にすればいい  

★ビューでは、結合したテーブルをビューとして作成しておくと便利だが、あくまでビューで参照しているテーブルや要素に対しては、updateやinsertはいくつかの条件が揃わないとできない（DBMSによる）。基本はselect文しかできない。  
🔶重要🔶:ビューは名前を付けてselect文である。そしてそのビューが参照されるとそのsql文を展開して実行する。つまり、sql文はビューを使う減っているが、結局展開するのでDBMSの負担は減らない。

🔺注意🔺

```sql
create view 学部名付きの学部テーブル as
select * from 学生
join 学部
on 学生.学部id = 学部.id
--上記の命令は失敗する（名前が一意ではないという）
--理由は、学生テーブルにも学部テーブルにも名前というカラムがあるので、名前分けをしないといけない
```

### 採番（さいばん：番号を採用すること、特定のデータに番号を割り当てること）

★各行に重複しない番号を振る方法であり、連番で番号が続いている時に、最後の番号が分からないと次にどの番号を振り分ければ分からない時に振る方法がある。（連番も並べないと最後の番号が分からないので、insertで重複しない番号を入れたい時に使う）  
⇒現場ではこの最後に使った番号を記録しておいた採番テーブルというものも作ったりする。  

★creta tableでそれぞれのカラムを作るときの設定で連番になるように設定する（DBMSによって異なる：P351）  
⇒下記のように設定すれば、insertした場合に自動で連番にしてくれる（重複しないように入れてくれる）  
⇒ということは、逆にこちらで明示的にinsert文でIDの数値を入力してしまわないように注意しないといけない

```sql
--mysqlの場合
ID integer primary key auto_increment,
--posgresqlの場合（serial型で設定する）
ID serial primary key 
```

```sql
create table 家計簿 (
ID serial primary key,
費目 varchar(10)  not null,
メモ varchar(20)
)
--
insert into 家計簿 (費目, メモ)
values ('給料', '初めての給料')
--
insert into 家計簿 (費目, メモ)
values ('光熱費', '今月分');
```

⇒この順番でやるとちゃんとIDの要素に順番に番号が入っていく。

★他にも「シーケンス」という機能があり、この機能を使うことで、現在の最後の値や現在の次に使うべき値を取り出すことが出来る。
⇒これはカウンターとほぼ同じで、、例えば現在の連番の最後の数字が４で次の扱うべき数字が５の時に、nextvalという文を使うと５という数字が取れる。ただし、一度シーケンスを作成してからnextvalを使うとその数値はシーケンスの中で記録され、次は、必ず6という数値になってしまう（戻せないカウンターだと考える：ロールバック効かないので間違えた場合、シーケンスを消す必要がある）

```sql
create sequence シーケンス名
drop sequence シーケンス名
```

⇒シーケンス作成後の命令文はDBMSによってかなり違う

```sql
--postgresqlでは関数を使ってアクセスする
--シーケンスを作成
create sequence 費目シーケンス;

--シーケンスを使って現在の最後の数字を取得
select currval('費目シーケンス');

--次の値に進み、次に使うべき数字を取得
select nextval('費目シーケンス');
```

```sql
--oracleの場合
create sequence ISTD;--シーケンスを作成して
INSERT INTO 学生
  (学籍番号, 名前, 生年月日, 血液型, 学部ID, 登録順)--登録準というカラムが最後にあり
VALUES
  ('B1101022', '古島 進', '1993-02-12', 'A', 'K', ISTD.NEXTVAL)
--登録順のvaluesの位置にシーケンス名とメソッドでnextvalを入れれば良い
```

```sql
--postgresqlは関数を使ってシーケンスを記述するので、例えばinsetr文にシーケンスを使えば、その連番とセットで要素をいれることもできる
create sequence 費目シーケンス;
insert into 費目 (ID, 名前)
values ((select nextval('費目シーケンス')), '接待交際費');
```

## IT世界のACIDについて

①原子性  
⇒トランザクションをすれば、その命令文をそれ以上分割できない一つの文とみなし、途中で処理を止めたりしない  
⇒途中で障害が起きたらrollbackをして実行前に戻すか、正確に実行された後のどっちかになる

②一貫性  
⇒create tableでカラムにnot nullや型でinteger、check(出金額 >= 0)を付ければ、それ以外の値は入らない

③分離性  
⇒排他的ロックを掛ければ、他の人がそのデータを変更できない  
⇒トランザクションの分離レベルを的確に設定する（ダーティリードや反復不能、ファントムリードをuncommited committedなど）

④永続性（記録した情報消えず、保持され続ける）  
⇒基本的に情報は一時的なメモリではなくハードディスクなどの磁気記憶媒体に記録されるが、それも壊れる可能性があることを考える。DBMSでは一定時間にバックアップが行われるようになっており、その出力を別のモノにコピーして隔離するとこが重要である。
（災害復旧対策：地震などで壊れる可能性を想定して別の地域にデータを確保）  

★バックアップを取る際に  
⇒オフラインバックアップ：バックアップ中にupdateやinsertをされても影響されないが、バックアップ中にサービスを停止しないといけない。
⇒オンラインバックアップ:サービスを稼働しながら、バックアップを取れる

🔶重要🔶：ケースとして、深夜０時に自動バックアップを取るとして、次のバックアップまでのデータ壊れたらどうするか？
⇒バックアップを頻繁にするわけにもいかないので、ログファイルを１０分周期でバックアップをする。
⇒やり方は、先ず朝９時に壊れたら、、前回のバックアップを使ってそこまで修正。次に、バックアップ後のデータをログファイルにある、SQL文を使って再実行する。
⇒ログに記録されているSQL分を再実行して、障害が発生する前の状態に戻すことを**ロールフォワード**という。

★テーブル、シーケンス、indexなどを合わせてデータベースオブジェクトと呼ぶ（DDLで作成したものがこれにあたる）
