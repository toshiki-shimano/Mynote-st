# SQLの実用

## データーベースをどう使い計画するか

★要件  
⇒例えば「お金の入出金を管理したい」という名目で管理するというように、何を目的にするのか？
⇒「商品在庫の管理をしたいのでDBをつくってほしい。全国の倉庫に商品が置いてあって、毎日夕方に一斉出荷するので、その時の商品コードを調べて、出荷後の在庫数と注文数を一緒に合わせて見たい」という時にどのように要件を聞いていくか？

①インタビュー（要件聴取）  
⇒要件を聞いたらどのような機能がほしいかを一覧にまとめて見やすくする。  
⇒エンティティ（情報のカタマリ）とそれが持っている属性（attribute）をどんな関連性があるか整理する。  
⇒エンティティは後にテーブルになるもの。  
⇒属性はカラムになるもの  
⇒関連がリレーションシップのこと

②概念設計  
⇒管理すべき情報はどのようなものかを整理。  
⇒どんな提案があったか（利用者情報、入出金情報などが必要など）

③論理設計  
⇒概念設計で明らかになった各情報について、どのようなテーブルを作り、どのようなカラムを作るか決める（付随的な部分は考えない）

④物理設計  
⇒論理設計で決めたカラムやテーブルの制約やカラムをindexの設定を確定する。  
⇒次にcreate tableをやる

🔺注意🔺：要件はそれぞれ違う人に聞くと違う基準になり要件がずれてしまったり、矛盾したりする時があるので、そこは話し合ってまたまとめる必要がある。

## ER図（概念設計）

★エンティティと属性とリレーションシップを俯瞰図にしたもの。  
⇒この形式はIEというジェームズマーチンさんが作った形式  
⇒入出金行為IDから内容を属性という  
⇒テーブル名をエンティティという  
⇒FKを外部キーという

★ER図の書き方

🔶入出金行為テーブル  
|入出金行為ID|
|---|
|日付<br>利用者名（FK）<br>内容|

①表の区切り線の上はプライマリキー（入出金行為IDやIDなど）  
②外部キーある場合は、テーブル同士を繋げる。このテーブル同士（エンティティ同士の）の数量的な関係を多重度（カーディナリティー）という。
⇒利用者テーブルと入出金行為テーブルは一人の利用者が複数の入出金行為をするので「1対多」の多重度があるといえる。  
⇒入出金行為テーブルと入出金明細テーブルでは、入出金行為があったら必ずその明細があるので「1対1以上」になり、一つの行為に二つ明細があるかもしれないので「1対多（1以上）」になる  
⇒費目テーブルと入出金明細テーブル。費目テーブルの費目カラムが複数の明細を付けることがある（無いときもあるので「1対多（0以上）」）  
⇒タグテーブルと入出金行為テーブル。タグは、一つの行為に複数付けることができるけど、一つのタグが複数の行為に付くこともあるので、お互いに「多（0以上）対多（0以上）」

--|------〇-|- は「1対0または1」の多重度

--|---------|- は「1対1」の多重度

--|---------(鳥爪)は「1体多」の多重度

--|-----〇--(鳥爪) は「1体多（0以上）」の多重度

★テーブル名（エンティティ）を導くヒント

①「要件」を聞いたらその文章の中から「名詞」を抜き出す  
②「要件」が実現されている状況を仮定して、「人物」「モノ」「事実」「行為」の用語を書き出す  
③不要な語は捨てる  
⇒カテゴリーが被っている（利用者名テーブルといずみテーブル）  
⇒計算や集計をすれば算出可能な数値は捨てる  
④関連がありそうなものをまとめる  
⇒「日付」「利用者」「内容」は「入出金行為」に関連する  
⑤４でまとめた関連性について、「～の～」の関係にある用語をグループ化  
⇒最初の「～」はテーブル名（エンティティ）最後の「～」が属性  

🔺注意🔺：テーブルに中にテーブルを作ることはできない（ER図）
⇒テーブルの属性がさらに何かを含みそうなときは、その属性をテーブル化して、外部キーを作る

## 論理設計

★概念設計であるER図の形では、そのままDBに落とし込めないため、利用する予定のDBが扱いやすいように変形する作業が論理設計

①「多対多」の分解  
🔶重要🔶：実はリレーショナルデータベースでは「多対多」をうまく扱うことが出来ないので、これに間の中間テーブルを入れることで、「1対多」に分解する。  
⇒入出金行為テーブル  タグ付けテーブル  タグテーブル。タグ付けテーブルを挟むことで外部キーも明確に。

②キーの整理  
⇒主キーを持たないテーブルは人口idを付けてあげる  
⇒不適切な主キーが無いか確認

③正規化（これが主な仕事）  
⇒矛盾したデータを格納出来ないようにテーブルを複数に分割していく作業  
⇒テーブルに一つのカラムが集中しすぎて情報がある（分割していない場合）、内容に重複があり分かりにくい、データ更新時に複数の箇所を修正しないといけない。修正を忘れたりもする。
⇒🔶重要🔶：優れたテーブル設計の原則は、**『1つの事実は1箇所に』**。これを実現するには、適切に分割することである

### 正規化について

★正規化によってテーブルが適切に分割されて状態を正規形といい、どの程度正規化されるかによって第１正規形から第５正規形まであり、基本は第３正規形まで。

★非正規形とは  
⇒一つの要素に二つ要素があったり、一つのセルに二つ要素があったり。つまり、テーブルの中にテーブルがある状態など（このことから、非正規形は繰り返しの列を含むともいう）  
🔶重要🔶：**繰り返し**とは、メモという要素に違う値が二つ入っていると、メモがという要素が連続で入っていることになる

⇒これはしっかり概念設計をやっていればほとんど非正規形になることはない。なぜなら、ER図では、非正規形を表現できないから。つまり、ER図がきちんと出来ているなら非正規形にはならない。

★非正規形を第１正規形へ

◎第１正規形のルール  
⇒テーブルの全てのrowとcolumnに１つずつ値が入り、繰り返しの列とセル結合がない状態であること  

①繰り返しのカラムの部分を別の表に切り出す  
⇒一つの要素が二つ以上の値を抱えている所のカラムを切り離す。  

|内容|費目ID|費目名|
|---|---|---|
|家賃を振り込んだ|H01|住居費|
||H17|振込手数料|

⇒費目IDと費目名を切り離す

②切り出したテーブルの仮の主キーを決める  
⇒カラムの中で一意なりそうなものを仮の主キーにする  

③切り出したテーブルの仮の主キーに元のテーブルの主キーを一緒にして複合主キーにする

★関数従属性  
⇒Aの値が決まれば、自動的にB値が決まるという関係をカラムBはカラムAに関数従属しているという  
⇒「利用者ID」と「利用者名」、「費目ID」と「費目名」などがそう  
🔶重要🔶：全ての非キー列は、主キーにきれいに従属しているべきである。

★第1正規形から、第2正規形へ  
⇒主キーと非キー列をきれいに従属させることが目的  
⇒複数列を主キーとしている場合、その主キーの一部だけに従属しているカラムがあってはならない（部分関数従属）つまり、複合主キーに丸々全ての非キー列が従属していることが目的。

|入出金行為ＩＤ|費目ID|費目名|金額|
|---|---|---|---|
|41001|H01|住居費|65000|
|41001|H17|振込手数料|525|

⇒この場合、入出金行為IDと費目IDが揃って金額が決まっているのでここはいいが、費目名というカラムは費目IDにしか従属していない（部分関数従属）

①複合主キーの一部に関数従属する列を切り出す  
⇒ここだと、費目名カラムを切って、費目テーブルと名づける

②部分従属先だったカラムに費目IDをコピーする。  
⇒そして、費目テーブルに費目IDをコピーしてくっ付ける。

◎入出金明細テーブル  
|入出金行為ＩＤ|費目ID|金額|
|---|---|---|
|41001|H01|65000|
|41001|H17|525|
◎費目テーブル  
|費目ID|費目名|
|---|---|
|H01|住居費|
|H17|振込手数料|

★第3正規形へ  
⇒推移関数従属関係を修正する  
⇒入出金行為IDに利用者IDは従属している、一方利用者名は利用者IDに従属している。  
🔶重要🔶：利用者名は**直接**主キー（入出金行為ID）に従属するべきである。各非キー列は同じ主キーに従属することが必要。よって、主キーに直接従属していないカラムを切り出す。これは、結局主キーが二つあるように見えるテーブルは何のテーブルかわからないので目的をはっきりさせる。

①間接的に主キーに関数従属するカラムを取り出す

②取り出したカラムに本当の主キーをつける。  
⇒利用者名を取り出したら、利用者IDを付けてあげる。

◎正規化まとめ  
⇒第1正規化（繰り返し列を離す）  
⇒第2正規化（部分従属を解消）  
⇒第3正規化（推移関数従属を解消）  

## 物理設計

★まず、どのDBMSを使うか決める（サポートする型や制約、インデックス、利用するハードウェアを考慮して決める）

①最終的なテーブル名、カラム名を決定する
⇒最終的なテーブル名はアルファベットが多い。その時に、予約語を使わないように気を付ける（userはダメ。usersなど⇒modelを作るときに単数名で付けるが、テーブル名は複数形になっている。予約語を防ぐため。）
⇒最終的なテーブル名カラム名を物理名、論理設計までの名前を論理名という

②カラムに型を決定する。
⇒使うDBMSによって違うかも

③制約、デフォルトを決定する

③どのカラムにインデックスを付けるか決める。

```sql
create index 費目idインデックス on 家計簿(費目id)
create index メモインデックス on 家計簿(メモ)
--外部キーや名前に付けることが多い
```

④その他
⇒ビューを作成したり、性能のためのあえて正規化を崩したり、巨大なテーブルを分割したり。

★これらは、最終的にER図では書ききれないので、テーブル設計仕様書という別文書に取りまとめられる。
⇒これを見ればどのカラムに制約をつけるか、型はどうするか、fkはどれか分かり、これを基にcreate tableをする。

★練習問題にて（エクセルのテーブル設計仕様書をまず確認）

```sql
--自身の答え
create table 部署 (
  部署番号 varchar(5) not null primary key,
  部署 varchar(10) not null
);

create table 役職 (
  役職コード char(1) not null primary key,
  役職名 varchar(10) not null
);

create table 社員 (
  社員番号 integer not null primary key,
  社員名 varchar(40) not null unique,
  役職コード char(1) not null references 役職(役職コード),
  年齢 integer not null
);

create table 部員 (
  部署番号 varchar(5) not null references 部署(部署番号),
  社員番号 integer not null references 社員(社員番号)
);
```

★解答より
①全てのテーブルにはprimary keyがあること
⇒中間テーブルは複合主キーになる
⇒primary key(部署番号, 社員番号)

②referencesは先に対象のテーブルが作成されていないと出来ないので、後に作る

③uniqueは、要素を考えた時に被ってはならないものに付け、primary keyには付けなくていい

④varchar型
⇒名前は、40
⇒役職名は、20

⑤char型
⇒決まった文字数なら、その文字数で

★下記が答え

```sql
-- 部署テーブルの作成
CREATE TABLE DEPT (
  DEPTNO   CHAR(2)     PRIMARY KEY,
  DEPTNAME VARCHAR(40) UNIQUE NOT NULL
);
-- 役職テーブルの作成
CREATE TABLE POS (
  POSCODE  CHAR(1)     PRIMARY KEY,
  POSNAME  VARCHAR(20) UNIQUE NOT NULL
);
-- 社員テーブルの作成
CREATE TABLE EMP (
  EMPNO    CHAR(5)     PRIMARY KEY,
  EMPNAME  VARCHAR(40) NOT NULL,
  POSCODE  CHAR(1)     NOT NULL REFERENCES POS(POSCODE),
  AGE      INTEGER     CHECK(AGE >= 0) 
);
-- 部員テーブルの作成
CREATE TABLE MEMBER (
  DEPTNO   CHAR(2)     NOT NULL REFERENCES DEPT(DEPTNO),
  EMPNO    CHAR(5)     NOT NULL REFERENCES EMP(EMPNO),
  PRIMARY KEY(DEPTNO, EMPNO)
);
```