# SQL基礎（まずここを押さえる）

* 前知識

1. 列（カラム）が縦のライン。行（row:要素）はカラムの各要素（中身）

2. RDBMSでは、カラムの型（データ型）をintegerとしたら、sqlで'100'と命令が来てもちゃんと数値に戻してくれる

3. 4大命令（select, insert, update, delete）直後の指定の値以外は、全て文字列ならコーテションを付ける。（不等号の後など）

4. 🔺注意🔺：delete命令は、where句を付けないと全データ削除になるので絶対に使わないこと！

5. insert命令は、where句は使えない

6. nullは不等号やイコールで判定出来ないのでisやis notを使う（where 出金額 is not null）

7. idが無いと、もしくはidに変わるカラムがそのテーブルに無いと、指定して消すことができない（同一を全て消して、もう一度追加するしかない）
⇒自然キー（普通に思い付きＩＤとなりうるもの）、人口キー（idとなるものが無いので、振り分けるために作るキー、複数キー（複数のカラムを合わせてキーとして扱う））

8. 🔺日付の範囲指定は注意！：DBMSによっては、where 日付 <= '2018-03-31'とした時に、これだと時間秒数を指定してないので、00:00:00で検索されてしまうかも。ということは、31日の深夜01時:12分:30秒は検索されないといくこと。なのでこの時は、2018-04-01にすると31日もしっかり含まれる。ただし、時間秒数が含まれないものももちろんあるので、その時は、<= 2018-03-31
でよい

9. current_date, currnt_timeはそのまま打てば数値が入る

10. 変な空白を入れるとうまくいかない  
select 個体識別番号,
       case 品種コード when '01' then '乳用種'
                   when '02' then '肉用種'
   when '03' then '交雑種'
       end as 品種, 出生日, 母牛番号 from 個体識別
where 母牛番号 in (select 個体識別番号 from 個体識別
           　　　　where 品種コード = '01')
⇒ここのエディタではよく分かるが、インデント中に全角スペースが入ってしまっている。時々、自身の打ったコードをエディタにコピーしてみるとわかるかも。

11. teut

## カテゴリー別

### select文

```sql
--select分の全貌
select 選択列リスト from テーブル名
where 条件式
group by グループ化するカラム
having 集計結果の並び替え
order by 最終結果の並び替え
```

★`as 名前`で検索結果の名前を変えることが出来る  
⇒form句に付けることもできる

### where句について

#### 前知識

* where句の後は、条件式のみ（where 日付 = '2018-02-22'などのブーリアンを問う式）  
⇒足し算などの計算式はできない

★不等号検索  
⇒`＜＞＝`を使う

```sql
select 都道府県名 from 都道府県
where  都道府県名 = 県庁所在地
--カラム同士の指定もできる。これだと、都道府県名と県庁所在地が同じものを検索。
where not 都道府県名 = 県庁所在地
都道府県名と県庁所在地が同じものではものを検索。
```

⇒🔶重要🔶：whereのカラムは一括指定できない、下記のコードを実装したい時は、全てandで結び、条件を付けないといけない　ｂ

```sql
UPDATE 成績表 SET 総合成績 = 'A'
 WHERE 法学 >= 80 AND 経済学 >= 80 AND 哲学 >= 80
   AND 情報理論 >= 80 AND 外国語 >= 80
   
--下記のコードは出来ない
update 成績表 
set 総合成績 = 'A'
where 法学, 経済学, 哲学, 情報理論, 外国語 >= 80
```

★Like検索  
（%は任意の０文字以上、＿は任意の１文字以上）  
（%や_を検索したい時は、$を頭に付けるとその％がエスケープされる。（'%100$%'）⇒１００％で終わるものを検索）  
⇒where メモ like '%1月%'  
⇒%1月は、1月という文字で終わることが条件。1月%は、1月という文字から始まることが条件  
⇒%1月%は、両側に文字あっても無くてもいいので1月という文字全てを含んだものを検索  

```sql
select * from 家計簿
where メモ like '%の%'
-- メモの中の「の」という文字を含んだデータを全て検索
```

★between検索（🔺注意🔺：指定した数値のちょうどの値も含まれる）

```sql
where 出金額 between 5000 and 10000
--5000~10000で絞る
```

★in/not in検索とanyとall
⇒in演算子は、()の中に一つでも合うものが含まれていれば、通ってしまう
⇒not inの中にnullは入れてはいけない（ただし、サブクエリならできる）

```sql
where メモ in ('コーヒー代', '給料')
--カラムの中身を含んだ値を検索
where 費目 not in ('食費', '交際費')
--カラムの中身を含まないそれ以外の値を検索

select 費目, メモ from 家計簿
where 費目 in ('食費', '給料', '日程', '交際費')
--日程という費目が無いが通る

select 費目, メモ from 家計簿
where 費目 not in ('食費', '給料', null)
--これは通るけど、全てnullで返ってきてしまう
```

★anyとallは必ず不等号を使う

```sql
where 出金額 < any (1000, 2000, 3000)
--このどれかより小さいならtrue
where 出金額 < all (1000, 2000, 3000)
--これら全てより小さいならtrue
--このanyとallのテクニックは、出金額 < 3000とかけばいいが、難しい絞りになると必要になってくる
```

★論理演算子（and or not）
⇒🔺注意🔺：優先順位があり、not⇒and⇒orの順になる

```sql
where 名称 = 'スッキリクエスト' and 販売店 = 'b'
--スッキリクエストを売っていて、かつ販売店がｂのお店を検索
where 名称 = 'スッキリクエスト' or 名称 = 'モンクエ'
--スッキリクエストかモンクエがあるデータを検索
where not 販売店 = 'b'
--こんな書き方もできる

🔺注意🔺：--下記の命令は、andが先に優先されてしまうので販売店ｂのゲームで検索されてしまう
where 販売店 = 'a' or 販売店 = 'b' and 名称 = 'ゲーム' or 名称 = 'DVD'

where (販売店 = 'a' or 販売店 = 'b') and (名称 = 'ゲーム' or 名称 = 'DVD')
--こうすれば、行きたいお店はaかbで、その中のゲームかDVDを見たい
```

### select命令のみの検索加工

⇒検索加工（検索結果にさらに加工して表示を変更する）

★distinct（これだけ記述場所に注意）  
⇒結果表示で指定したカラムの重複している部分を一つにまとめる

```sql
select distinct 学生名 from 成績表
--これで重複している名前が出てこない
```

★order by（select文の最後に書く）とlimit  
⇒ASCが少ない順、DESCが多い順  
⇒カラムを指定するだけではなく、指定した（selectの後に）列番号を指定することもできる（単純に数値の３や２を指定するだけ  
⇒つまり、`select 出金額, 入金額 from 家計簿`とした場合に列番号の１は出金額で列番号の２は入金額。  
⇒🔺注意🔺：列指定は副作用がありあまり使わない（順番が変に逆になってしまうことがある）

```sql
select * from 家計簿
order by 日付 desc
--descを除くとascになる
select * from 成績表
order by 経済学 desc, 哲学 desc
--最初にきた条件から順番に並び替え

select * from 成績表
order by 3, 4 desc
--カラム全体の左から3番目のカラムをASCで4番目のカラムをdescで並び替えcfcqq
select 費目, 出金額 from 家計簿
 order by 出金額 desc limit 3
--上から順番に３つまで表示 
```

★offset・fetch（MysqlやmariaDBは使えない）  
⇒先頭から数行だけ取り出す  
⇒order by句の後ではなくても使える。(sqlserverを除いて)  
⇒offset 先頭から除外する行数 rows (ここの部分は省略ができないので必要ないなら0にする)  
⇒fetch next 取得行数 rows only

```sql
select 費目, 出金額 from 家計簿
 order by 出金額 desc
offset 0 rows
 fetch next 3 rows only
```

```sql
select 飼育県 as 都道府県名, 個体識別番号, 
       case when 雌雄コード = '1' then '雄'
            when 雌雄コード = '2' then '雌'
       end as 雄雌 from 個体識別
where 飼育県 in (select 飼育県 from 頭数集計
                 order by 頭数 desc
                 offset 0 rows
                 fetch next 3 rows only)
--where句は頭数集計の上位三位の飼育県をin演算子に入れたい
```

### update

★set句には、カラム指定をしてから変更値（set 入金額 = 1000, 出金額 = 2000, メモ = 'test' ）  
⇒🔺注意🔺：where句を入れないと全て更新されてしまうよ！

★set句では、すでに値を入っていて、同じ値を入れようとするとエラーになる

### delete

★必ずwhereを設定する

### insert

```sql
insert into 家計簿 (日付, 入金額)
values ('2018-02-18', 1000)
-- insertの（）に指定した分valuesが必要
-- もし、insert後の（）が無い場合全てのvaluesの値を入力する必要がvあり、空欄はnullにする
```

### 計算式

★前知識

* 計算式を導入できる所は３つあり  
①select分のすぐ後ろのカラムの指定の所  
②insert intoのvaluesの（）の中  
③updateのset句の中

* DBMSで、文字列の結合は、「||」か「＋」を使う

```sql
select 出金額, 出金額 + 100 as 出金額１００プラス, 'SQL' 入金額 from 家計簿
--カラムに足したり、元々ないカラムを追加できる。この場合のSQLはrow分ＳＱＬと全て入ってしまう。
```

★case演算子(🔶重要🔶：caseの後に値を入れるか入れないかは、カラムの内容に入れていくかいかないか⇒入れていくなら、そのデータがデフォルトで入る。入らないなら、thenの条件が入る)

```sql
select 費目, 出金額, 
 case 費目 when '居住費' then '固定費'
           when '水道光熱費' then '固定費'
           else '変動費'
 end as 出費の分類
from 家計簿アーカイブ
where 出金額 >= 0
----------------------------------------------------------------

select 費目, 入金額, 
 case when 入金額 < 5000 then 'お小遣い'
      when 入金額 < 10000 then '一時収入'
      else 'それ以外の収入'
 end as 収入の分類
from 家計簿アーカイブ
where 出金額 >= 0
```

```sql
select trim(メールアドレス) as メールアドレス,
  case when 年齢 >=20 and 年齢 < 30 then '20代'
       when 年齢 >=30 and 年齢 < 40 then '30代'
       when 年齢 >=40 and 年齢 < 50 then '40代'
       when 年齢 >=50 and 年齢 < 60 then '50代' 
  end 
  || ':' || 
  case 性別 when 'M' then '男性'
            when 'F' then '女性'
  end) as 属性 from 回答者
--case文は||で足すこと（くっ付けること）ができる
```

```sql
select 飼育県 as 都道府県名, 個体識別番号, 
       case when 雌雄コード = '1' then '雄'
            when 雌雄コード = '2' then '雌'
       end as 雄雌 from 個体識別
---どっちの書き方でもいい（上記の方がわかりやすいかな）
select 飼育県 as 都道府県名, 個体識別番号, 
       case 雌雄コード when '1' then '雄'
                       when '2' then '雌'
       end as 雄雌 from 個体識別
```

🔶重要🔶
①まず、ここで入力しているフィールドは、selectのすぐ後ろのカラムを羅列するところ（表示する項目）であり、そこに記載をするのだから、カラムの項目を増やすために書いているという前提がある

②case 対象項目 when '実際にある要素' then '変更内容' end as カラム名

③elseが使える、書き方が2種類ある（大きいのは、caseの後にカラムを入れるか入れないか）

### 関数

* 前知識  
⇒前後の「,」を忘れないように  
⇒カラムとして表示するならasをつける  
⇒select文の後ろ、where句の条件式の中などで使える  
⇒関数は入れ子で呼び出せて、中から処理する  
（select メモ, length(trim('sql ')) as トリム from 家計簿 ⇒ ここでは、一度trimして'sql'になってから、lengthする）

★length()メソッド  
⇒（）の中に、カラムを入れる。文字数を出す

```sql
select メモ, length(メモ) as メモの長さ, 出金額 from 家計簿
where length(メモ) <= 10 --10バイト以下のメモだけ取得する
```

★trim()メソッド  
⇒文字の前後の空白を取り除く  
⇒char型は、char(10)とすると'abc'でも’abc       ’と入るので、これを消したい時に使う

```sql
select メモ, trim(メモ) as 空白除去 from 家計簿
```

★replace()メソッド  
⇒replace(置換対象、置換前の値、置換後の値)

```sql
update 家計簿
set メモ = replace(メモ, '購入', '買った')
------------
update 受注
set 文字数 = length(replace(文字, ' ', ''))
--鈴木 巧などtrim()は前後のなので、真ん中の空白を取るにはreplaceを使う
```

★substring()メソッド
⇒substring(文字列を表す列, 抽出を開始する位置, 抽出する文字)

```sql
--費目の要素で、1~3文字目に「費が」あるものだけを抽出する
select * from 家計簿
where substring(費目, 1, 3) like '%費%'
--水道光熱費とは出ない
```

```sql
case substring(trim(メールアドレス), length(trim(メールアドレス))-1, 2)
---substringの第二引数は、-を付けることで後ろから参照できるらしい
```

```sql
--メモが8文字以上の時にその文字に・・・を付けて8文字以上部分を省略したい
select 日付, 費目,
 case when length(メモ) >= 8 then substring(メモ, 1, 8) || '...'
 else メモ
 end as メモ, 入金額, 出金額
from 家計簿
```

★concat()メソッド  
⇒カラム名を置いてそのまま連結

```sql
SELECT CONCAT(費目, メモ) FROM 家計簿
--上記だとカラム名concatと出て、本当にそのまま、「食費コーヒーを購入」「教養娯楽費書籍を購入」とそのままつながる
select concat(費目, ':' || メモ) as 費目詳細 from 家計簿
--表示カラムは費目詳細で「食事：コーヒーを購入」と出る
```

```sql
--メールアドレスをtrimして、年齢と性別を一つの項目にして、性別はMなら男性,Fなら女性にする
select trim(メールアドレス) as メールアドレス,concat(年齢 || '代', ':' || 
 case 性別 when 'M' then '男性'
           when 'F' then '女性'  
 end) as 性別年齢 from 回答者
```

★round()メソッド  
⇒指定ケタで四捨五入  
⇒round(数値を表す列, 区切る桁)（２なら、第2小数点で。ー２なら2桁目で（３８０なら４００になる））

```sql
select 出金額, round(出金額, -2) as 百円単位の出金額 from 家計簿
```

★trunc()メソッド  
⇒trunc(数値を表す列, 区切る桁)
⇒四捨五入ではなくただの切り捨て。使い方がround()と同じ。

```sql
--1ドル110として表記し、小数点以下を切りたい
select trunc(入金額 / 110, 0) || '$' as 入金額ドル, trunc(出金額 / 110, 0) || '$' as 出金額ドル from 家計簿
```

★power()メソッド  
⇒べき乗にする

```sql
select 出金額, power(出金額, 3) as 3乗した出金額 from 家計簿
```

★currnt_date と current_timeメソッド  
⇒🔶重要🔶：（）が要らない

```sql
insert into 家計簿 (日付, 出金額, 入金額)
values (currnt_date, 1000, null)
```

★cast()メソッド  
⇒カラムの型を変更できる  
⇒cast( 変換する値 as 変換する型)

```sql
select cast(出金額 as varchar(20)) + '円', 入金額 from 家計簿
```

★coalesce()メソッド  
⇒（）内にいくつでも引数を持ち、その中を左から順に検査して、nullではないもの発見したら入れる。nullだったら次の引数の値を検査して入れる。ここには、普通の文字やカラムも入れられる。  
⇒nullの代替値を簡単に決められる

```sql
select 日付, 費目, coalesce(メモ, '(メモはnullです)'), 入金額, 出金額 from 家計簿
```

🔶重要🔶；まず、メモの値が順番に上からそのまま入っていくが、代入されていく過程でメモの中にnullがあったら、第2引数の値が入る。もちろんさらにその第2引数もnullなら第3引数が入ってとなる  
⇒つまり、selectの後ろに表示したいカラムを並べていく訳だが、その中にnull持ちのカラムがあった場合、そのまま指定すればそこの値は空欄になるが、それが分かりにくい時は代替の値を入れることができるというメソッドなので見方によっては便利！

```sql
--書体コードというカラムにnullが入っていて、それを元にデータを挿入していきたい時
select 受注日, 受注id, 文字数, 
       case coalesce(書体コード, 1)
       when '1' then 'ブロック体'  
       when '2' then '筆記体'  
       when '3' then '草書体'
       end as 書体名,
       case coalesce(書体コード, 1)
       when '1' then 100  
       when '2' then 150  
       when '3' then 200
       end as 単価,
       case when 文字列 < 10 then 0 
       else 500 
       end as 特別加工料,
       from 受注
order by 受注日, 受注id
```

### 集計関数(length()などのメソッドとは違う存在)

★メソッドは一行一行にメソッドをかけていくのでrowの数は変わらないが、これは集計なので結果は1行になる  
🔶重要🔶：selectのすぐ後ろのカラム指定と、order by句、having句でしか使えない（updateとかの文では使えない）

🔶重要🔶；`select 出金額, sum(出金額) as 出金額合計 from 家計簿`と打つとエラーになる。（結果予想は、出金額リストの横に一行合計が出る凸凹の表になる⇒この表はsqlでは認められずエラーになる）

★sum(合計), max(最大), min(最小), avg(平均)  
⇒それぞれの（）内にカラムを入れる。また、()内で計算することもできるsum(出金額 * 1.08)  
⇒countとmaxとminは文字列にも使える。maxは並び替えて最後の文字列を出す。日付型は、maxとminで使える

```sql
select
  sum(出金額) as 合計出金額,
  avg(出金額) as 平均出金額,
  max(出金額) as 最も大きな散財,
  min(出金額) as 最も少額の支払い
from 家計簿
------------
select avg(coalesce(出金額, 0)) as 出金額の平均
--出金額にnullがある場合、0を代入して計算もできるが、別にnullは基本無視して計算されるので付けなくてもよい
```

★count(*) ⇒単純にrowの数をカウント（nullも含める）  
★count(列)⇒検索結果の指定列に関する行数（nullは含めない）  
⇒（）内にdistinctを入れると重複した内容が一つにまとまる  

```sql
select count(*) as 食費の行数
  from 家計簿
 where 費目 = '食費'
--費目が食費の行数を出せる
select count(distinct 費目) from 家計簿
--上記は費目が何種類あるか調べられる
```

### グループ化

🔶重要🔶：selectの最初に来るカラムとgroup byが同じではないといけないらしい？そうにも見えるが、selectの後ろの表示するカラム数とgroup byの数が合わないといけない

```sql
SELECT 商品区分, 商品名, COUNT(*) FROM 販売履歴
 GROUP BY 商品区分, 商品名 
HAVING AVG(価格) >= 10000

--group byに商品区分を入れないとエラーになる
SELECT 商品区分, 商品名, COUNT(*) FROM 販売履歴
 GROUP BY 商品名
```

🔶重要🔶：他にも、group byを使わなくても select 出金額, sum(出金額) from 家計簿だと、表示されるrowがsumは１つなので凸凹になってしまう

★group byとカラムだけで集計関数のカラム別の計算にしてくれる  
⇒先に結果をグループ化してわけることによって、それぞれのsumになれば行列数は合う  
⇒where句には、集計関数は使えない。もし絞り込みをしたいなら、集計後の絞り込み専用尾のhavingがある  
⇒WHERE句はグループ化されたデータに対して絞り込みを行うことはできません。WHERE句とGROUP BY句を併用した場合、WHERE → GROUP BYの順でクエリが評価されるため、グループ化された結果をWHERE句の段階で利用できないのです  
🔶重要🔶：havingはどうやら集計関数と不等号使わないといけないらしい  

```sql
select 費目, sum(出金額) as 費目別の出金額 from 家計簿
group by 費目
---------
select 費目, sum(出金額) as 費目別の出金額 from 家計簿
group by 費目
having sum(出金額) > 0
```

```sql
--p199
--事由区分ごとにcountしてそれぞれの事由区分に名前をつける
select case 
when 事由区分 = '1' then 'メンテナンス'
when 事由区分 = '2' then 'リリース作業'
when 事由区分 = '3' then '障害対応'
when 事由区分 = '9' then 'その他'
end as 事由区分,
count(*) as 入室回数 from 入退室管理
group by 事由区分

--入室回数が一番多い社員の社員名と入室回数
select 社員名, count(*) from 入退室管理
group by 社員名
having count(社員名) >= 10

--p199 ここでは、日付を基準にするのか、社員数を基準にするのかで分かれる。
--社員数を基準にすると日付と社員数の数に違いあるので凸凹になってしまう
select 日付, count(社員名) as 対応社員数 from 入退室管理
where 事由区分 = '3'
group by 日付
```

## サブクエリ（副問い合わせ、ネスト）

★コツが３つある

①まず、見方としてネストされているselect文から処理されていく

②基本的に３つのパターン

* 単一サブクエリ（検索結果が1行1列になる値  
⇒select文の後ろやfrom句、updateのset句の中、一つのデータと照合を行うwhere句の中

```sql
--set句での例
update 家計簿集計
 set 平均 = (select avg(出金額) from 家計簿アーカイブ 
             where 出金額 > 0 and 費目 = '食費')
where 費目 = '食費'
--select後の表示カラム（表示する列（合計）を入れようとしている）
select 日付, メモ, 出金額,
       (select 合計 from 家計簿集計
       where 費目 = '食費') as 過去の合計額 from 家計簿アーカイブ
where 費目 = '食費'       
```

* 複数サブクエリ  
⇒複数のrowからなる単一のカラム  
🔶重要🔶：これは、複数の値を候補に挙げられる入力場所にしかできない。つまり、単一比較の入力場所に記述してもどれと比較していいかわからないから。従って、複数の値を候補に挙げたい時は、anyやallを使う  
⇒in()の中。any()、all()の中などで使える

```sql
select * from 家計簿集計
where 費目 in ('食費', '交際費','水道光熱費')
--
select * from 家計簿集計
where 費目 in (select distinct 費目 from 家計簿)
--この場合だと家計簿の中で被ってない費目は出てこないので注意
```

★anyとallは必ず不等号を使う

```sql
where 出金額 < any (1000, 2000, 3000)
--このどれかより小さいならtrue
where 出金額 < all (1000, 2000, 3000)
--これら全てより小さいならtrue
--このanyとallのテクニックは、出金額 < 3000とかけばいいが、難しい絞りになると必要になってくる
```

```sql
select * from 家計簿
where 費目 = '食費' and 出金額 < any (select 出金額 from 家計簿アーカイブ where 費目 = '食費')
--いっぺんにたくさんの値と比較したい時にカラムごと呼び出している（このサブクエリの結果の複数の値のうちでどれかより低いならtrue）
```

★複数サブクエリの中にnullが入ってしまっている時は、２つ解決方法がある  
⇒not inなどの中にnullがあると全てnullで返ってきてしまう  

```sql
SELECT * FROM 家計簿アーカイブ
 WHERE 費目 IN (SELECT 費目 FROM 家計簿
                WHERE 費目 IS NOT NULL)
--参照したいカラムにnullが含まれているか分からない時に、where文に参照するカラムにis not nullを付けておく

SELECT * FROM 家計簿アーカイブ
 WHERE 費目 IN (SELECT COALESCE(費目, '不明') FROM 家計簿)
--こちらは、もしnullが参照されたら不明と入れる仕組みにしている
```

```sql
select 個体識別番号,
       case 品種コード when '01' then '乳用種'
                      when '02' then '肉用種'   
                      when '03' then '交雑種'
       end as 品種, 出生日, 母牛番号 from 個体識別
where 母牛番号 in (select 個体識別番号 from 個体識別
                   where 品種コード = '01')
--ここのinを＝で間違えていた。＝にすると単一サブクエリの結果を求めるので、複数値がある検索はエラーになる。
--「＝」は一つの結果なら使える。複数ならinかany
```

* 表サブクエリ
⇒この名前の通り情報が表丸ごとになるので、テーブル名を書けるfrom句とinsert intoのvalueに相当する所に書ける  
⇒insert intoは一回の命令で一行しか追加出来ないが、下記の方法を使えば一回のselect文で複数のrowを追加できる

🔶重要🔶：insert intoのサブクエリは()無しでselectが始まるので注意！  
⇒厳密には、これはサブクエリではなくinsert分の特殊構文である

🔺注意🔺：unionの際のカラム指定を間違えると計算が違ってしまう。この場合、日付というカラムがあるから同じ給料が双方にあっても出力されて計算されるが、無い場合はunionで一つにまとめられてしまうので結果計算が少なくなってしまう

```sql
-- asで名前を付けたら、「.」を使ってメソッドみたいにカラムを呼び出せる
SELECT SUM(SUB.出金額) AS 出金額合計
  FROM (SELECT 日付, 費目, 出金額
          FROM 家計簿
        UNION
        SELECT 日付, 費目, 出金額
          FROM 家計簿アーカイブ
         WHERE 日付 >= '2018-01-01'
           AND 日付 <= '2018-01-31') AS SUB
```

```sql
--selectのあとのカラム数は、insertのカラム数に合わせる
INSERT INTO 家計簿集計(費目, 合計, 平均, 回数) --4つ
SELECT 費目, SUM(出金額), AVG(出金額), 0 --4つ
  FROM 家計簿
 WHERE 出金額 > 0
 GROUP BY 費目
 /*まず、費目で出金額が０以上のものを検索してから、費目をグループ化して、グループ化した費目をそれぞれinsertして、それぞれのグループ化した出金額をそれぞれ、平均もそれぞれ。つまりここでは、最終的なrowの追加は、まとまったカラム数分が入る。
 因みに指定されなかったカラムはnullになる*/
```

⇒もし、上記のinsert文で新しく追加するテーブルと参照するテーブルが同じカラムで同じ型ならinsertのあとの（）は省略できる

* 相関サブクエリ  
⇒これは、サブクエリだが理論を考えずにそのまま覚える  
⇒『表示体カラムが他のテーブルと同じ要素のカラムを表示したい』というときのみぐらいか？

```sql
select 費目, 合計 from 家計簿集計
where exists
(select * from 家計簿 where 家計簿.費目 = 家計簿集計.費目)
--サブクエリなのに外側のカラムを指定している（家計簿集計.費目）
/*上から読み下すと、単純に家計簿集計から、費目と合計を出すだけ。ただし、費目に関しては、家計簿テーブルの費目と同じ
費目のみを取り出したい時に、existsを使って、サブクエリの中で外側の家計簿集計テーブルも使って記述する。*/
```

## ★基本

◍テーブルからcolumn(カラム、列)を検索

```SQL
select 出金額 from 家計簿 
```

⇒家計簿がテーブル

◍全検索

```SQL
select * from 家計簿
```

⇒アスタリスクが全てを検索

◍条件検索

```SQL
select 日付, 費目, 出金額 from 家計簿
  where  出金額 < 3000
```

◍row（行）の挿入（テーブルに新たに要素を追加する）

```SQL
insert into 家計簿
  values ('2018-02-25', '居住費',  '3月の家賃',  0, 85000)
```

⇒区切りはダブルコーテーションではなくシングルじゃないとエラー。カラムごとの項目分要素が無いといけない。無いなら、nullを入れる。

◍rowの更新

```SQL
update  家計簿
set  出金額  =  90000
where  日付  =  '2018-02-25'
```

⇒WHEREは別に日付ではなくてもOK。選択した、カラムと要素が合っていれば、特定できる。

◍rowの削除

```SQL
delete from  家計簿
where  日付  =  '2018-02-05'
```

◍like演算子（ワイルドカードの事）とbetween演算子（andの事）

```SQL
select  *  from  家計簿
  where  メモ  like  '%１月%'

  where  出金額  100  and  1000 /*ちょうどの値でもtrueになる*/
```
  
⇒％：任意の０文字以上の文字列  
⇒＿：任意の文字１文字  
⇒andは100~1000のこと  

* ～マッチング例～

★`％1月`は1月で終わる要素を検索。
★`1月％`は1月で始まる要素を検索。

◍in/not  in演算子

```SQL
select * from 家計簿
  where 費目 in ('食費',  '交際費')
/*費目カラムで食費と交際費に合う要素を取得*/
  where 費目 not in ('食費', '交際費') 
```

⇒値が（）内に列挙した複数の値のいずれかに合致するか判定する

◍anyとall演算子(副問い合わせでしか使えない時がある)

```SQL
select * from 家計簿
  where 出金額 < any (1000, 2000, 3000)
/* 出金額が２５００で、＜なら、２５００は３０００より小さいので式はtrue(どれか一つでも条件を満たせば良い)*/
  where 出金額 < all (1000, 2000, 3000)
/* 出金額が１０００で、＜なら、１０００は（）の１０００より小さないのでfalse*（全ての条件を満たさないといけない）/
```

⇒必ず＜＞比較演算子を使う。

◍distinct：select文に付加すると、結果表の中で重複を取り除く

```SQL
select distinct カラム from テーブル名
```

◍order by：select文の最後に記述すると、指定した列の値を基準として検索結果を並べ替えて取得  
⇒昇順はasc（量が少ない順）。降順はdesc（量が多い順）

```SQL
select * from 家計簿
  order by 入金額 desc, 出金額 desc
```

◍offset-fetchとlimit：並べ替えた結果の一部だけ表示したい
⇒offset句：先頭から除外する要素を決める。つまり、要素が５個あり、それを降順で並べて、一位と二位を除外した三位を上から順に出す、つまり三番目が一番上になる。`offset  3  rows`  
⇒fetch句：いくつ要素を出したいかを指定する（5個の要素の内、3つだけなど）。例えば、offsetで除外されてデータが３つしかないのに、`fetch next 5 rows only`と5個のデータが出るようにしても3つしか出ない。
⇒limit：select fromの後やorder byの後に単純につけると表示数を制限できる。

```SQL
select 費目, 出金額 from 家計簿
 order by 出金額 desc
 offset 2 rows
 fetch next 2 rows only

select 費目, 出金額 from 家計簿
 limit 3
```

### 集合演算子

🔶重要🔶：使える条件は、それぞれ足しあうカラムの型が一致していることと、足しあうカラム数が同じ。また、order by句を使う時は最後のselect文に記述する。order by句で列番号で指定しない時は（カラム名やas名）、ベースのselect文を指定する
⇒どうしてもお互いカラム数が合わない場合、少ない方にnullでカラムを追加すると合う

★和集合（union）  
⇒全く同じデータが双方にある場合は、そのデータを一つにまとめる。共通部分があっても少しでも違えば別々に出力する
⇒分かりにくいが、基本はそのままデータ表示するがお互いに同じデータがあったときのみまとめる。（片方に同じデータが2つあった場合にもまとめられる。同じ給料0でも日付が違えば出力）

🔺注意🔺：日付と費目と出金額同士なら、日付が違うので双方の同じ給料0は出力される。しかし、費目と出金額だけなら給料0という違いに他の違いがないので一つにまとめられてしまう。つまり、結果が少なくなってしまう  
⇒よって、サブクエリで計算をする時に、足したい項目が一つにまとまらないようなカラムの選び方をしないと正しく計算できない

⇒union (all) にすると重複しているものまで返す

```SQL
select 費目, 入金額, 出金額 from 家計簿
union
select 費目, 入金額, 出金額 from 家計簿アーカイブ
 order by 2, 3, 1 --order byで列番号を指定
```

★差集合（except）  
⇒双方で被っているものを弾いて、片方にしか無いものを残す（つまり、どっちかにしかないものが残る）
⇒select文から重複している分を引いて残す。テーブルの順番に注意！ベースのテーブルを決めて、そこから引くテーブルを決める。引く方を先に記述してしまうと結果がおかしくなる。

```SQL
select 費目 from 家計簿
except
select 費目 from 家計簿アーカイブ
```

★積集合（intersect）
⇒双方で重複している部分だけを残す（共通項目がわかる）

```SQL
select 費目 from 家計簿
intersect
select 費目 from 家計簿アーカイブ
```
