# SQL応用

★テーブルには必ずidとなるものが必要
⇒ある2つのテーブルの行に情報としての関連がある場合、その関連をリレーションシップという
⇒他のテーブルの関連行を指すための値を格納することでリレーションシップを結ぶ役割を担っているカラムを外部キー（foreign_key）という。Userモデルのuser_idがNoteモデルのカラムの中に入っている、このuser_idが外部キーで,
Userモデルのidが主キー

★なぜ外部キーがあるといいか？

* データベースの負担が減る
⇒給与を給料と変更したい時に10万行のrowを一つ一つ参照していくのは大変（update 家計簿 set 費目 = '給料' where 費目 = '給与'）  
⇒これが費目idが給与に振り分けられていて、ただ費目idの給与を給料として書くだけなら、1行の変更で済む

* テーブルに納める情報を分割できる
⇒更新や入力ミスの訂正において分かれている方がわかりやすい、操作しやすい（しかし、ただテーブルを分ければいいというものではない。リスク分散がきちんと想定された分け方を考える）

★データベースとは、電子的な媒体にファイルなどの形式で保存蓄積したもの。その情報の取り扱いの中で、データベースの種類において複数の表形式でデータを管理するものをリレーショナルデータベースという。このデータベースには、複数の表があり、その表をテーブルという。（表形式の情報の集積）
⇒自身がSQLの命令を送るのは、DBではなくDBMS（データマネージメントシステム）と呼ばれるプログラムで、このプログラムがDBに対してSQL命令を受けると検索したり表同士を結合したりする。このプログラムがないとDBは操作できない。DBMSというプログラム中で表形式のRDBMSはpostgresql,mysql,oracleDB,mariaDB,sqlite,sqlserverなどがある

## 応用

★リレーショナルデータベースの機能のjoinをまとめる

### join

★費目idがある家計簿は、１，２，３としか振られてないので中身が分からないが、費目idテーブルを結合すれば（家計簿テーブルの費目idと費目idテーブルのidを紐づけると、その費目が出力される）

```sql
select 選択列リスト from テーブルA
 join テーブルB
 on 両テーブルの結合条件
--selectの直後には両方のテーブルのカラムを指定できる
select 日付, 名前 as 費目, メモ from 家計簿
join 費目
on 家計簿.費目id = 費目.id
--表示したい要素名をselectにおく
```

★一つのrowに対して、それにあった（結合条件に合った）データを引っ張る。  
⇒もし一つのrowに対して合う条件が二つ以上ある場合、元の一つを複製して引っ張てきた条件分rowを増やす  
⇒もし一つも無いなら、逆にそのrowは消滅してしまう。（その項目のrow消えてしまう）nullが入っていた時もそうである。  
🔶重要🔶：この場合消滅されると困るのでnullでも結合させるように左外部結合（left join）がある。  
⇒左外部という考え方は、元のテーブルの方でnullがある、対象外がある時に結合する方の値を消滅ではなくnullとして入れる  
⇒右外部（right join）は、結合する方にnullがある。  
⇒完全結合（full join）は両方にnullがあっても表示する  
⇒左外部、右外部、完全を外部結合、rowが消滅してしまうのを内部結合という。  
(Mysqlとmariadbはfull joinが使えないのでunionを使う（p260）)

🔶重要🔶：selectの後ろのカラム名がテーブル同士で被っている場合は、`家計簿.メモ, 家計簿アーカイブ.メモ`のようにやる
⇒その場合にfrom句のテーブルにasで名前を付けておくとわかりやすい

```sql
select 日付, K.メモ, H.メモ
  from 家計簿 as K  -- 家計簿テーブルに別名K を設定
  join 費目 as H    -- 費目テーブルに別名H を設定
    on K.費目ID = H.ID
/*ここでは、費目idが関係ないように見えるが、ｋのメモに対して、hのメモを並べる時に、費目idに沿った接合をしている。
ここに、full joinを入れると費目テーブルのid3の項目はnullになって追加される。考え方の順番としては、まず家計簿テーブルの費目idと費目テーブルのidは紐づいている。joinの大元を家計簿テーブルにする場合、その費目idが存在する分、費目テーブルの要素は入っていく。その時に、費目テーブルの入れていく要素の中に大元の要素と合致しないものがあれば、最後にnullで返す（完全結合）*/

これが基本で、、以下のコードは、、

select 日付, 費目.名前, 費目.経費区分ID from 家計簿 -- 家計簿テーブルに対して…
join ( select * from 費目
       where 経費区分ID = 1
       ) as 費目     -- 副問い合わせの結果を結合
on 家計簿.費目ID = 費目.ID
/*上記の考え方に沿っていくと、今度は、join句で接合する費目idの数を限定していて、その条件でonを条件づけているので、経済区分が１のものしか紐づけない、と、その１に紐づくものしか検索しない。サブクエリをjoin句に指定する場合、asが必要*/
```

### joinでの整理

* selectには、両方のカラムがおける

* 外部キーある場合は結合条件に入れる。
⇒ここの入力を間違えければ指定するのかしないのかはあまり考えなくて良い

* お互いのカラムにnullがある場合は、完全結合でnullと対象外を防ぐ

* join onを繰り返すと三つ以上のテーブルも結合でき、上から順番に結合されていく（has manyが親、belong toが子）

* 難しいのがjoin句にサブクエリが入ること（サブクエリの条件でonの条件が狭まる）
⇒サブクエリをjoin句に指定する場合、必ずasが必要

```sql
select 日付, 費目.名前, 費目.経費区分ID from 家計簿 -- 家計簿テーブルに対して…
join ( select * from 費目
       where 経費区分ID = 1
       ) as 費目     -- 副問い合わせの結果を結合
on 家計簿.費目ID = 費目.ID
--この場合、家計簿と費目テーブルのrowが合わないように見えるが、joinの結果に対して、家計簿カラムの数を減らすのか
```

* 同じテーブル同士を結合することをself joinという（asで別々の名前にする）  
⇒この場合外部キーという考えはもはやない

```sql
select A.日付, A.メモ, A.関連日付, B.メモ
from 家計簿 as A
left join 家計簿 as B
on A.関連日付 = B.日付
--A関連日付に沿ってBテーブルのカラムが入っていく
```

～練習問題～

|A1|A2|
|---|---|
|1|2|
|2|4|

|B1|B2|
|---|---|
|1|2|
|3|null|

```sql
--問題
SELECT A1,A2,B1,B2 FROM A JOIN B ON A.A1 = B.B1
```

⇒順番にやるのが正解
①出るのは、A1,A2,B1,B2。A1,A2は普通にrow分出る。B1に対しては、A.A1 = B.B1で同じものがあるときには、出力されるので、B1の一行目はA1に対応するB1は1とでる。B1の二行目は、A2対するB1の要素ないので対象になる。さらに外部結合ではないので、この時点で、今回出力するA1,A2,B1,B2のrowの2行目は消滅する。最後にA1の一行目に対するB2は、A.A1 = B.B1のB1の要素なので2となる

```sql
SELECT A1,A2,B1,B2 FROM B JOIN A ON B.B2 = A.A1
```

⇒まず、Bテーブルが主役！Bに関して出すカラムは全て出ると考える。そうすると、１，３，２，nullは出る。次に、B2とA1が紐づいているということで、出力するカラムをB2とA1のカラムにしぼって考えるので、それ以外のB1とA2はリレーションのカラムに紐づいた並びになる。なので、B2とA1を先に記入すればあとのカラムは出る

```sql
SELECT A1,A2,B1,B2 FROM B LEFT JOIN A ON B.B2 = A.A1
--左外部という考え方は、元のテーブルの方でnullがある
```

⇒先ほどにleftを加えたもの。大元のB2の要素のnullに来た時にその紐づいている値とそれに平行する値は全てnullになる。ただ、B1カラムには、nullと３が並行しているので、nullの時にB1は３になる

🔶重要🔶：大元のテーブルのカラムは全て出で基準である。結合条件は、大元のカラムに沿って結合する方のカラムが入っていく。他のカラムはその結合条件に合わせて並行して入っていく。

★p268の練習問題

```sql
--部署の名前と社員の名前を出したい
select 社員番号, 社員.名前, 部署.名前 as 部署名 from 社員
join 部署
on 社員.部署id = 部署.部署id
--今回部署テーブルなのに、部署idというカラムで書いてあるので非常に分かりにくい
```

⇒まず出したいのは、社員テーブルの社員番号と名前と部署名（これは社員テーブルにはない）。次、joinで部署名を出すために必要なテーブル考えてそれを記述。（部署）次に何も考えずにonで二つのリレーションを記述。  
⇒部署名は、部署idの並行なので、出力カラムに部署テーブルの名前として記述（部署.名前）
⇒ここで🔺注意：そうすると、社員テーブルと同じ名前というカラムを使うことになるので、社員テーブルの名前にも社員とつける（社員.名前）

```sql
select A社員.社員番号, A社員.名前, B社員.名前 as 上司名 from 社員 as A社員
left join 社員 as B社員
on A社員.社員番号 = B社員.上司id
--社員名の隣に上司名を付けたい
```

⇒同じテーブルを結合するときは、from句にas。join句にasをつけて、別々の名前をつける。そして出力カラムもそれぞれのテーブル名を参照したカラム名にする（A社員.社員番号, A社員.名前, B社員.名前）

```sql
select 社員番号, 社員.名前, 部署.名前 as 部署名, 支店.名前 as 勤務地 from 社員 
join 部署
on 社員.部署id = 部署.部署id
join 支店
on 部署.本部拠点id = 支店.支店id
```

⇒この場合はまず、カラムの中で部署名が別のテーブルが必要なのでjoinで出す。次に部署テーブルに対して支店テーブルを紐づける。最初のjoinをできたら、一度、適当な値を勤務地に挿入して途中経過を見ると分かりやすい

```sql
--このほかに社員数を出したい（東京支店には二人いる）
select 支店.支店id as 支店コード, 支店.名前 as 支店名, 社員.名前 as 支店長名, 社員数.社員数 as 社員数 from 支店
join 社員
on 支店.支店長id = 社員.社員番号
join (select count(*) as 社員数, 勤務地id from 社員
      group by 勤務地id) as 社員数--ここで帰るのは、勤務地idとその社員数の2列の表、この表の中での勤務地idに並行するcountは２であり、その２を引き出すには、社員数テーブルの勤務地idと支店テーブルの支店idが紐づけば、単純に支店idを出力した時の並行のcount(社員数)カラムは２である
on 支店.支店id = 社員数.勤務地id
--まずここまで作る
```

⇒東京支店には二人いるので、社員テーブルの勤務地idと支店テーブルの支店idが合う人をcountする。ということは、社員テーブルと支店テーブルを結合したものが必要になる。  
⇒ここでは、東京だけしか支店がないのでわかりにくいが、もし他の場所もある場合、東京支店ごとの紐づいた社員の検索をしてそれぞれのcountをしないといけない（ここでgroup byを使うことが必要）
⇒selectの後に勤務地idが必要なのは、勤務地と支店テーブルのidが合うことが必要だから(勤務地をグループに分けてそれぞれをcountする（ここでは勤務地idが一つしかない）)
⇒joinのサブクエリは新しい表を作るという発想を元に考えてみる。（今回なら、社員テーブルをさらに絞った表になる表をjoinに指定ている）

```sql
--上司と違う勤務地の社員の一覧表
select 社員A.社員番号, 社員A.名前, 部下支店.名前 as 本人勤務地, 上司支店.名前 as 上司勤務地
from 社員 as 社員A

join 社員 as 社員B
on 社員A.上司id = 社員B.社員番号
--上司idを先にもってこないと結果が逆になる
and 社員A.勤務地id <> 社員B.勤務地id
--<>は等しくない
join 支店 as 部下支店
on 社員A.勤務地id = 部下支店.支店id
join 支店 as 上司支店
on 社員B.勤務地id = 上司支店.支店id
```

？なぜ上司idを先にもってこないと
？社員Bにしなくていけない理由

### joinの見解

* joinをするとselectの後に二つのテーブルのカラムを記入できる
⇒大元にnullか対象外がある場合、そのrowは表示されない。結合する側にnullか対象外がある場合もそう
⇒表示したい時には、大元のnullがある時にはleft join
⇒select後にテーブル同士で名前が被ったら、テーブル名を付けてカラムをつける（社員Aテーブル.社員番号）

* テクニック
①まず。どのテーブルのカラムをベースに使うか決める。
②出したいカラムに必要なon句とjoin句のテーブル名を考える。
③基本on句の記述は、双方の共通を書けばいい
④on句の条件にしたカラムを基軸として他のカラムがそれに並行してならぶ

* join句にサブクエリを使ったら、必ずasで名前を付ける

* 同じテーブル同士で検索する場合、表示したい方をonの最初の比較条件にもってくる（逆にすると結果も逆になる）

* onの後に使えるand
⇒`on 社員A.上司id = 社員B.社員番号 and 社員A.勤務地id <> 社員B.勤務地id`（社員勤務地が同じにならない組み合わせもの）
⇒`on region.id = office.region_id and office.region_id = 3`(idが３のものだけに絞ってる)
  