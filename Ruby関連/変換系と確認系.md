# 変換と確認

## 前知識

* 自身の作成してdefでも？を付ければ真偽値を問える

★length()メソッド（size()メソッド）

★文字列掛け算
⇒`print "hi!" * 10`でhi!が１０回繰り返される

## 紛らわしいもの

★is_a?
⇒レシーバーが引数内のクラスと合っていればtrueを返す

```ruby
"hello".is_a?(String)
```

***

★equal?  
⇒object_idが同じ時にtrue

★==  
⇒オブジェクトの内容が等しいかどうか判断。データ型だけは違ってもok。クラスはダメ

★eql?  
⇒**ハッシュの**キーとして２つのオブジェクトが等しいか判断。また、普通の比較でもデータ型が違うとfalse
⇒「＝＝」と違って、「1.0」と「1」はtrueにならない  

★===
⇒よくcase文のwhen節で使われるが、「クラスに含まれる」「中身が一緒」であればいいが、、  
🔺注意🔺:比較位置が左右逆だとエラーになる
⇒「===」は左にクラスの基準（ArrayやInteger、Stringなど）を置く。case文のwhenの部分は"when節のオブジェクト === case節のオブジェクト"になっており、when String なら、Stringが左のwhen節オブジェクトになるようになっている。

```ruby
p "1" == 1 #false
p 1.0 == 1 #true

a = "hello"
b = a
p a.equal?(b) #true

a = "hello"
b = "hello"
p a.equal?(b) #false

p "hello" === "こんにちは" #false
p String === "hello" #true
p "hello" === String #false
```

***

## ★to_rとr to_f（ｐ３０）とrjast

★丸め誤差について  
⇒コンピュータが二進数を使って計算するために、きちんとした数字で返ってこない  
⇒0.1 * 3.0 = 0.300000000000004なってしまう。これを解消するためには、小数点の計算は、rationalとto_fを使う  
🔶重要🔶：丸め誤差はバグに繋がるので注意！小数点を扱う時は、rとto_fを利用する。  
🔶重要🔶：「r」はintegerそのものに使えるが、もしその数字が変数に入っている場合は、rationalizeメソッドで「r」と同じことを出来る。掛けるほう、掛けられるほうどっちもメソッドを付ける必要あり

```ruby
0.1r * 3.0r 
#結果は、3/10
(0.1r * 3.0r).to_f
#結果は、0.3

0.1 * 3.0 # 0.30000000000000004
a = 0.1
b = 3.0
print (a.rationalize * b.rationalize).to_f
# ()と.to_fが無いと、3/10 あると0.3
```

★to_r
⇒文字列の数値を分数にできる
⇒"2/3".to_r で2/3に変換
⇒「3r」を有理数リテラルという

```ruby
r = 2 / 3r
print r #2/3
```

★to_f  
⇒整数を小数点にする  
⇒n = 1   puts n.to_fで1.0になる

★rjust
⇒右寄せ
🔺注意🔺：第二引数は、コーテーション！

```ruby
"0".(5) #"    0"
"0".rjust(5, "0") #"00000"
```

★round
⇒四捨五入

```ruby
1.4.round # 1
1.5.round # 2
-1.4.round # -1
-1.5.round # -2
```

★to_sym
⇒文字列をシンボルにできる

## 進数直し

★to_s
⇒integerに使い引数を使うとその進数にできる
⇒"0".to_s(16) は"0"     "255".to_s(16) は"ff"

⇒to_sでシンボルをstring型にできる

★hex
⇒stringクラスのメソッドで16進数を10進数に直す

## その他

★.nil?  
⇒対象物がnilなら真を返す

★.class  
⇒"hello".classで型が分かる

★.delete_at()
⇒配列の指定したインデックスを削除（**戻り値は削除した方**）  
⇒a = [1, 2 ,3]
⇒a.delete_at(1) # 2が戻り値
⇒a = [1, 3]

★.abs
⇒絶対値にすることができる（-を取ることができる）

★.empty?
⇒空がどうか

★.include?
⇒含まれているかどうか

```ruby
"watch".include?("at") # true
"watch".include?("in") # false
```

★.odd?(奇数)と.even?(偶数)

```ruby
1.odd?
2.odd?
1.even?
2.even?
```

★.ancestors
⇒クラスオブジェクトに対して含んでいるモジュールやスーパークラスの情報が配列で返される。

## gsubメソッド

⇒文字列を別の文字へ置換する。また、特定の文字を別の文字へ置換するだけでなく、正規表現を用いて該当する箇所を置換したり削除したりできます。文字列を整形するメソッドとしては非常によく使う
⇒文字列を文字列として返す。途中結果を変数に代入しなくて良し

★正規表現を使わない場合
⇒`文字列.gsub(置換したい文字列, 置換後の文字列)`

★正規表現を使う場合
⇒`文字列.gsub(/正規表現/, 正規表現に該当した箇所を置換した後の文字列)`

```ruby
"置換前です。".gsub("置換前", "置換後")
#結果："置換後です。"
```

```ruby
#Paizaにて一部の文字を決まった数値に変更するシステム
a = gets
a.gsub!(/A|I|Z|G|O|S|E/, "A"=>"4", "I"=>"1", "Z"=>"2", "G"=>"6", "O"=>"0", "S"=>"5", "E"=>"3")
print a
```
