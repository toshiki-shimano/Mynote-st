# 正規表現（Regexpクラス）

★元文（当てられる文）  
★正規文（//を使った文）

## 正規表現一覧

★エスケープ文字（\でエスケープ）
⇒「/」「.」「*」

★「\d」  
⇒1文字の数字を表す

★「\w」  
⇒[a-zA-Z0-9_]を表す

★「.」  
⇒任意の1文字を指す

★「*」  
⇒直前の文字が0文字以上。**つまり付ける位置に注意！**  
⇒a*ならaが0文字以上。 *なら半角スペースが0個以上  

★「+」  
⇒直前の文字が1文字以上。**つまり付ける位置に注意！**  
⇒a+ならaが1文字以上。+なら半角スペースが1個以上

★「{}」  
🔺注意🔺:{~}の間に半角スペースを入れると効かない  
⇒{1, 2}は✖。{1,2}は◎  
⇒直前の文字がその個数あり  
⇒a{3}ならaが三個

★「[]」  
⇒[]内の文字を含む

## 前知識

★正規表現が合っているかどうかは、Rubularを使う  
⇒🔺超注意🔺:ただし、本物クレジットカードの番号や暗唱番号は絶対に入れないこと

★「=~」で正規表現の文字比較になる  
⇒if文の真偽にも使える  
⇒「!~」で合わなければ真

```ruby
"123-4567" =~ /\d{3}-\d{4}/
# 0
# この位置は逆でも可能。（/\d{3}-\d{4}/ =~ "123-4567"）
# これだとマッチした部分の位置を返すので0番目という答えが返る
# マッチしない時はnilが返る

"1977年7月17日" =~ /\d+年\d+月\d+日/

if "123-4567" =~ /\d{3}-\d{4}/
  puts "マッチしました"
else
  puts "マッチしませんでした"
end
```

★キャプチャ
⇒matchメソッドを使って、正規表現を（ ）で囲むとそこを取り出せる  
⇒キャプチャ番号を参照する時は0からではなく1から。そして、キャプチャ番号の０番目はマッチした全体を取得する  
⇒🔶重要🔶：キャプチャには名前を付けることもできる(?<year>\d+)。これでは、何番目の何の値か気にしなくて良くなる  

◍matcnメソッド（StringクラスとRegexpクラスどちらとも対応（基本はマッチデータオブジェクトを返す））  
⇒つまりintegerには使えない  
◍scanメソッド（マッチして、キャプチャされた部分を配列で返す）

```ruby
text = "私の誕生日は1977年7月17日です。"
m = /(\d+)年(\d+)月(\d+)日/.match(text)
m[0] # "1977年7月17日"
m[1] # "1977"
m[2] # "7"
m[3] # "17"
m[-1] # "17"
m[2, 2] # 2番目から二個取得、["7", "17"]
m[1..3] # ["1977", "7", "17"]

# ifを使えば
if m = /(\d+)年(\d+)月(\d+)日/.match(text)
else
end

#名前キャプチャ
text = "私の誕生日は1977年7月17日です。"
m = /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/.match(text)
m[:year] # "1977"
m[1] # "1977" 連番でも名前でもできる
```

🔶重要🔶：名前キャプチャは、「左辺に正規表現」、「右辺に変数を置く」とその名前が変数として使える  
🔺注意🔺:ただし、右辺と左辺が逆だと使えないのと、変数にいれてしまうと使えない。（ダイレクトに/～/を使って左辺に置く）

```ruby
text = "私の誕生日は1977年7月17日です。"
if /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/.match(text) =~ text
  puts "#{year}/#{month}/#{day}"
end
#1977/7/17
```

## 正規表現に使えるメソッド

★scanメソッド  
⇒引数で渡した正規表現にマッチする部分を配列に入れて返します。元文の中にスペースがあるとそこを区切る  
⇒正規文にキャプチャをすると配列の配列で返す  
⇒キャプチャを使いたくない時は「?:」でエスケープする（scan.(/(?:\d+)年(?:\d+)月/）

```ruby
"123 456 789".scan(/\d+/)
#["123", "456", "789"]
```

★[]、sliceメソッド（sliceメソッドはエイリアス)  
⇒[]に正規文を渡すとマッチした部分を返す  
⇒複数マッチする場合、最初にマッチしたものを返す  
⇒正規文にキャプチャを付けた後、第二引数を番号指定するとその連番の値を取れる。もちろん、名前がついていればその指定もできる（:yearや"year"で指定）

```ruby
text = "123-4567 456-7890"
text[/\d{3}-\d{4}/]
# "123-4567"
text = "郵便番号は123-4567です"
text.slice(/\d{3}-\d{4}/)
# "123-4567"
```

★splitメソッド  
⇒文字列を分割して配列にするためのメソッド。splitメソッドは第1引数に区切り文字を指定できるが、引数を指定しない場合は空白文字で区切られる。空白文字として扱われるのは、” “(半角スペース)、”\n”(改行コード)、”\t”(タブ)  
⇒正規文を渡すと、マッチした部分を区切って配列を返す

```ruby
text = "123,456-789"
text.split(",") #["123", "456-789"]
text.split(/,|-/) #["123", "456", "789"]
# 「|」は「または」の意味
```

★gsubメソッド  
🔺注意🔺:第二引数をダブルコーテーションではなく、**シングル**で統一する。ダブルだとうまく変換できていない時あり  
⇒第1引数の正規文にマッチした文字列を、第2引数の文字列に置き換える  
🔶重要🔶：なんと第2引数にハッシュでルールを引き渡すとルールを複数指定できる

```ruby
text = "123,456-789"
text.gsub(/,|-/, ":")
# "123:456:789"
```

```ruby
hash = {"," => ":", "a" => "z", "_" => "-"}
text = "123,456,789appple,banana_melon_cherry"
puts text.gsub(/,|a|_/, hash)
#123:456:789zppple:bznznz-melon-cherry
# gsubの第1では、hashのキーをもう一度指定。もちろん、直接ハッシュの中身を第二引数に書いてもいいが、変数を当てた方がスマート
```

★match?メソッド  
⇒組み込み変数＄より変換する動作がないので高速  
⇒元文と正規文が合っているかどうか真偽を出す



★例

```ruby
#下記のoldをexpectedに変えるときにどうするか？
class TestHas < Minitest::Test
  def test_hash
    old_syntax = <<~TEXT
    {
      :name => 'Alice',
      :age=>20,
      :gender  =>  :female
    }
    TEXT
    expected = <<~TEXT
    {
      name: 'Alice',
      age: 20,
      gender: :female
    }
    TEXT
    assert_equal expected, convert_hash(old_syntax)
  end
end

def convert_hash(old_syntax)
  old_syntax.gsub(/:(\w+) *=> */, '\1: ')
end
# :\w+で「:name」まで取れる。スペースに対して「　＊」という形でスペースが無くてもあっても含む
# キャプチャをすることで文字数関係なくその値を取れる。そして第2引数で\1とすると1番目にキャプチャされた文字を指定。
# それに:をつければこの形に変更できる
```

## 応用

★Regexpクラス

```ruby
Regexp.new("\d{3}-\d{4}")
#/\d{3}-\d{4}/と同じ
```

★🔶重要🔶：％記法が便利ｋ！（%r!~!）  
⇒「//」を使うとエスケープしないといけないが、%r!~!ならエスケープせずできる

```ruby
text = "https://rubular.com/*"
if text =~ %r!https://rubular.com/*!
  puts "合ってます"
else
  puts "合ってません"
end
# 合ってます
if text =~ /https:\/\/rubular\.com\/\*/
  puts "合ってます"
else 
  puts "合ってません"
end
# 合ってます
```

## 正規表現のオプション

⇒もちろん同時につかうこともできる %r!~!ix など

◍「i」
⇒大文字小文字区別しない

```ruby
p "Hello" =~ /hello/i
# 0(合っている)
p "Hello" =~ %r!hello!
# nil
p "Hello" =~ %r!hello!i
# 0
```

◍「m」
⇒任意の文字を表す「.」が\ｎにも一致するようになる。

◍「x」
⇒空白文字（半角スペースや改行文字）が無視され、#を使ってコメントも入れられる
⇒元文に半角スペースがあるとできないが、、
⇒コメントの際には、「＃」の前後に半角分スペースを空けること
⇒🔶重要🔶：半角スペースも入れたいなら、エスケープでできる

```ruby
text = "helloputsputs"
p text =~ %r!
hello # 1文字目
 putsputs # 2文字目

!x
```

```ruby
#スペース前にエスケープを置くといける
text = "hello puts puts"
p text =~ %r!
hello # 1文字目
\ puts\ puts # 2文字目

!x
```

## 組み込み変数「$」(正規表現できちんと結果を得られているかチェックできる)

★=~やmatchメソッドを使った後は、そのマッチした結果を「$」という特殊変数で表すことができる
🔶重要🔶：取れているかこれでチェックできる
⇒二つ正規表現があった場合は、二つ「$」書けば結果も二つ出るが、一つだと最後の結果が出る

```ruby
text = "本日は、2021年5月23日です"
text =~ %r!\d{4}年\d{1,2}月\d{1,2}日!
p $~ #<MatchData "2021年5月23日">
p $& # "2021年5月23日"
#以下はキャプチャしないとnilになる
text =~ %r!(\d{4})年(\d{1,2})月(\d{1,2})日!
p $~ # <MatchData "2021年5月23日" 1:"2021" 2:"5" 3:"23">
p $1 #"2021"
p $2 #"5"
p $3 #"23"
```


