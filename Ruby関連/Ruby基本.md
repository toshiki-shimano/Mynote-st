# Rubyとは

* Rubyでは、すべてのものはオブジェクトである。 すべての情報の塊・コードには、固有のプロパティとアクションを与えることができる。 オブジェクト指向プログラミングでは、プロパティはインスタンス変数、アクションはメソッドと呼ばれます。  

* Rubyでは、プロパティ(property)のことをアトリビュート(attribute)という。

## rubyのバージョン

★rbenv  
⇒OSなどに標準装備されているrubyは、最新ではない可能性が高いため、rbenvなどを使ってバージョン管理をする。rbenvを使うと、複数のrubyのバージョンに切り替えることができるようになる（プロジェクトや開発現場によってバージョンが異なる為に必要）

★エンコーディングとマジックコメント  
⇒ruby1.9だとエンコーディングがUS-ASCIIだったので半角の英数字しか使えず、日本語を使うには上記に # encoding: utf-8 というものを書かないといけなかった。ruby2.0以上でエンコーディングがUTF-8になったのでマジックコメントは不要になった。shift-jisを使いたいなら、マジックコメントを使えばいい。

## rubyの基本ルール

⓪Rails専用のメソッドとごちゃまぜにしないこと  
⇒.usderscore  .in?など

①変数名は基本スネークケースで書く  
⇒special_price（スネーク）とspecialPrice（キャメル）

②数字から始まる変数名は使えない

③シングルクオートは、\nと式展開（#{ }）はそのまま文字列になってしまう  
⇒バックスラッシュの打消しは、ダブルクオート内でやること（name = "alice" puts "hello, \#{name}"）  
⇒hello, #{name}という結果に

④整数同士の割り算は、整数になってしまう  
⇒1 / 2 = 0になってしまう。  
⇒1.0 / 2.0 = 0.5になり、片方が小数点であればよい（1 / 2.0 = 0.5）

⑤べき乗は**を使う  
⇒ puts 2**3 = 8になる

⑥丸め誤差について  
⇒コンピュータが二進数を使って計算するために、きちんとした数字で返ってこない  
⇒0.1 * 3.0 = 0.300000000000004なってしまう。これを解消するためには、小数点の計算は、rationalとto_fを使う  
🔶重要🔶：丸め誤差はバグに繋がるので注意！小数点を扱う時は、rとto_fを利用する。  
🔶重要🔶：「r」はintegerそのものに使えるが、もしその数字が変数に入っている場合は、rationalizeメソッドで「r」と同じことを出来る。掛けるほう、掛けられるほうどっちもメソッドを付ける必要あり

```ruby
0.1r * 3.0r 
#結果は、3/10
(0.1r * 3.0r).to_f
#結果は、0.3

0.1 * 3.0 # 0.30000000000000004
a = 0.1
b = 3.0
print (a.rationalize * b.rationalize).to_f
# ()と.to_fが無いと、3/10 あると0.3
```

⑦論理演算子の||と&&は&&の方が優先  
⇒優先順位を変えたいなら、（）を使う  
⇒||と&&の戻り値は左から順に評価していき、その途中で真になったらすぐ戻る  
（nil || false || 2 || 3 の戻り値は「２」：左から、偽、偽となり2で確定）
（1 && false && 3 はfalse。&&はfalseやnilが入っていると強制的に偽になる⇒１は確定で次にfalseと書いてある時点で偽を真としているから）  
（user = find_user("alice") || find_user("bob")は左から検索して、途中で真になればそれを返す。つまり、aliceの検索が偽にならないとbobの検索は行われない）

```ruby
条件１ && (条件２ || 条件３) && 条件４
#これは、条件１かつ 条件２か３ かつ条件４
```

★and or notは||や&&より優先度は低い  
⇒&&だと()が必要でも、andなら()が必要ではない時がある。

```ruby
user.valid? && send_mail_to user #これはエラーになる
#理由は、(user.valid? && send_mail_to) userと解釈されてしまうため
user.valid? and send_mail_to user # エラーにならない
#(user.valid?) and (send_mail_to user)という扱いになる
```

⑧🔶重要🔶「式」「文」の違い  
⇒「式」は、値を返し、変数にだいにゅうできる（if文と呼ばれるが、ifは結果を返すのでこのような意味ではif式といってもよい）  
⇒「文」は、値を返さず、変数に代入しようとするとエラーになる

⑨擬似変数(変数みたいに代入できない)

★種類

* true, false, nil

* self,\__FILE__, \__LINE__, \__ENCODING__

### puts print p について

★ターミナルへの標準出力でよく使われる。
⇒puts, printはto_sメソッドを呼び出して文字列に変換
⇒pは、inspectメソッドを呼び出している
⇒puts, print, pはkernelモジュールに定義されているメソッド

* puts
⇒改行を加えて、変数の中身やメソッドの戻り値をターミナルに出力する

* print
⇒改行を加えない

* p
⇒改行を加えて、引数で渡されたオブジェクトそのものを返す。

### 参照とは

🔶重要🔶：参照とは、、Rubyの変数には、オブジェクトそのものが入っているわけではなく、オブジェクトへの参照が格納されている。変数に他の変数を代入したり、メソッドの引数として渡したりすると、新しい変数やメソッドの引数は元の変数と同じオブジェクトを参照する
⇒変数がどのオブジェクトを参照しているかは、object_idメソッドで確認できる  
🔺注意🔺
⇒a = "hello"とb = "hello"のaとbはオブジェクトとしては別物
⇒.equal?()メソッドは、objectが同じかどうか調べる

🔺注意🔺
⇒参照元は、途中の変数が完全に変わらない限りは、影響を受けない
⇒つまり完全に変わると受ける
⇒つまり！！完全に変更しなければ、最初の変数の値を維持できる

```ruby
a = "hello"

b = a
c = b.upcase
puts a
# aはhelloのまま
a = "hello"

b = a
c = b.upcase!
puts a
# aはHELLO
# aは途中のbが完全に変わってしまったので、参照元のaも影響を受ける
```

### メソッドの定義について  

⇒メソッドは最後に評価された式が戻り値  
⇒rubyではreturnは脱出に使われることが多い

```ruby
def greeting(country)
  return "countryを入力してください" if country.nil? #対象がnilなら真となる
  #returnがあるので、このif文が真ならここで止まる（下のif文には行かない）
  if country == "japan"
    "こんにちは"
  elsif country == "us"
    "hello"
  else 
    "???"
  end  
end
puts greeting("japan") #こんにちは
puts greeting(nil) #countryを入力してください
```

🔺注意点🔺  

* 定義したdefの引数の数（本引数）と、使う時の引数の数が合わないとエラーになる。
⇒これは、本引数にデフォルトを入れておくとエラーにならない
⇒本引数にデフォルトで変数を入れることもできる（def greeting(country = town)）

```ruby
def greeting(country = "japan")
  if country == "japan"
    "こんにちは"
  elsif country == "us"
    "hello"
  else
    "???"
  end
end
puts greeting # こんにちは
puts greeting("us") # hello
```



## %記法

★%q!～!で挟むとシングルクオートになる  %Q!～!で挟むとダブルクオートになる  %!～!もダブルクオートになる  
⇒p %q! hello, test! で " hello, test"  
⇒！マークの代わりに、? と {}も使える

## ヒアドキュメント

★複数行にわたる長い文字列を書くには、こっちを使う  
⇒識別子は自由につけていいが、文章の中に出てこない単語にする  
⇒最初の識別子-を入れると最後の識別子をインデントしてもよくなる  
⇒ヒアドキュメントは式展開が可能  
🔶重要🔶：~を使うと最後の識別子はインデントしていいし、途中の文字列の頭のインデントは無くして詰めてくれる
⇒ただし、一番左に近いものインデントをなくすだけ

```ruby
<<~TEXT
  おはよう
  こんにちは
    さようなら
    
  ありがとう
TEXT
#これだとおはようまでは詰めてくれる。間の空欄はそのまま
```
🔶重要🔶：開始の識別子は1つの式として見なされるので、この開始の識別子をメソッドの引数として渡したり、この識別子にメソッドを与えることができる

```ruby
#<<識別子
#  1行目
#  2行目
#  3行目
# 識別子

a = <<TEXT
これはヒアドキュメントです。
複数の行の文字列を書くのに適しています。
いかかでしょうか
TEXT
puts a

def some_method
  <<~TEXT
  こんにちは
  さようなら
  おはよう
  こんばんは
  TEXT
end
puts some_method

a = "alice"
mail = <<~TEXT
ようこそ、#{a}さん
TEXT

puts mail

a = "ruby"
a.prepend(<<TEXT)
java
php
TEXT
puts a
# aのrubyの前に()内のもの入れる時に、ヒアも入れられる

a = <<TEXT.upcase
php
java
ruby
javascript
TEXT
puts a
# ヒアの中身が全て大文字になる
```

## 数値の扱い

★数値に0bを付けると2進数になる。0xを付けると16進数になる  
★to_s(2)とやるとstringではなく2進数でという意味になる
🔺注意🔺：ビット積と普通の2進数の乗算はちがう
⇒1010 &(ビット積の文字) 1100は1000。一のくらいから0 * 1と0 * 0は0になる。

```ruby
puts 0b11111111
# 255
puts 0b1101
# 7
puts (0b101 | 0b10).to_s(2)
# 5 + 2 = 7 結果:111

```

★指数表現（小数点をずらすための関数）

* 2.5e5
⇒「2.5e5」とは2.5に10の5乗を掛けることであり「250000.0」
⇒10の5乗は「10  10  10  10  10」

* 2.5e-4
⇒「2.5e-4」とは2.5に10の-4乗掛けることであり「0.00025」

### 標準ライブラリと組み込みライブラリとgem（外部ライブラリ）について

★組み込みライブラリは、インストール(require)しなくてもいきなり呼び出せる

★組み込み**ではない**標準ライブラリとgemは、requireする必要がある
⇒Dateクラス（require "date"する）
⇒組み込みではない標準ライブラリ：date,csv,json,yaml
⇒gem：rspec, bundler, rails, nokogiri（ただし、rubyをインストールした時に一緒にインストールされるgemもあり）

🔶重要🔶
★requireする時は、gemや組み込まれてないライブラリか、同じディレクトリ内のファイルを呼ぶ時に使う
★require_relativeは相対で呼ぶのでディレクトリの階層がずれているときにわかりやすい
★require系は1回しか読み込まないが、loadというメソッドは無条件で何回でも呼べる。

## ボッチ演算子

★nilかもしれないオブジェクトに対して、安全にメソッドを呼び出したい時はボッチ演算子を使う（&.メソッド）
⇒ボッチを使ったメソッドは、nilならエラーではなくきちんとnilを返してくれる

```ruby
a = nil
print a&.upcase
# 出力はされないが、エラーにもならない
# &を外すとエラーになる
```

## ||=

★||=は、左がnilやfalseでないなら、右辺を代入する

```ruby
limit = nil
limit ||= 10
# limitは１０
```

## 「!!」（絶対にtrueかfalseを返す）

★確実にtrueかfalseを返したい時に使う（p175を参照）
